{"ast":null,"code":"/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file formatters.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\n\"use strict\";\n\nvar utils = require('web3-utils');\nvar Iban = require('web3-eth-iban');\n/**\n * Will format the given storage key array values to hex strings.\n *\n * @method inputStorageKeysFormatter\n *\n * @param {Array<Number|String|BN|BigNumber>} keys\n *\n * @returns {Array<String>}\n */\nvar inputStorageKeysFormatter = function (keys) {\n  return keys.map(utils.numberToHex);\n};\n/**\n * Will format the given proof response from the node.\n *\n * @method outputProofFormatter\n *\n * @param {object} proof\n *\n * @returns {object}\n */\nvar outputProofFormatter = function (proof) {\n  proof.address = utils.toChecksumAddress(proof.address);\n  proof.nonce = utils.hexToNumberString(proof.nonce);\n  proof.balance = utils.hexToNumberString(proof.balance);\n  return proof;\n};\n/**\n * Should the format output to a big number\n *\n * @method outputBigNumberFormatter\n *\n * @param {String|Number|BigNumber|BN} number\n *\n * @returns {BN} object\n */\nvar outputBigNumberFormatter = function (number) {\n  return utils.toBN(number).toString(10);\n};\n/**\n * Returns true if the given blockNumber is 'latest', 'pending', 'earliest, 'finalized' or 'safe'\n *\n * @method isPredefinedBlockNumber\n *\n * @param {String} blockNumber\n *\n * @returns {Boolean}\n */\nvar isPredefinedBlockNumber = function (blockNumber) {\n  return ['latest', 'pending', 'earliest', 'finalized', 'safe'].includes(blockNumber);\n};\n/**\n * Returns the given block number as hex string or does return the defaultBlock property of the current module\n *\n * @method inputDefaultBlockNumberFormatter\n *\n * @param {String|Number|BN|BigNumber} blockNumber\n *\n * @returns {String}\n */\nvar inputDefaultBlockNumberFormatter = function (blockNumber) {\n  if (this && (blockNumber === undefined || blockNumber === null)) {\n    return inputBlockNumberFormatter(this.defaultBlock);\n  }\n  return inputBlockNumberFormatter(blockNumber);\n};\n/**\n * Returns the given block number as hex string or the predefined block number 'latest', 'pending', 'earliest', 'finalized', 'safe', 'genesis'\n *\n * @param {String|Number|BN|BigNumber} blockNumber\n *\n * @returns {String}\n */\nvar inputBlockNumberFormatter = function (blockNumber) {\n  if (blockNumber === undefined) {\n    return undefined;\n  }\n  if (isPredefinedBlockNumber(blockNumber)) {\n    return blockNumber;\n  }\n  if (blockNumber === 'genesis') {\n    return '0x0';\n  }\n  return utils.isHexStrict(blockNumber) ? typeof blockNumber === 'string' ? blockNumber.toLowerCase() : blockNumber : utils.numberToHex(blockNumber);\n};\n/**\n * Formats the input of a transaction and converts all values to HEX\n *\n * @method _txInputFormatter\n * @param {Object} transaction options\n * @returns object\n */\nvar _txInputFormatter = function (options) {\n  if (options.to) {\n    // it might be contract creation\n    options.to = inputAddressFormatter(options.to);\n  }\n  if (options.data && options.input) {\n    throw new Error('You can\\'t have \"data\" and \"input\" as properties of transactions at the same time, please use either \"data\" or \"input\" instead.');\n  }\n  if (!options.data && options.input) {\n    options.data = options.input;\n    delete options.input;\n  }\n  if (options.data && !options.data.startsWith('0x')) {\n    options.data = '0x' + options.data;\n  }\n  if (options.data && !utils.isHex(options.data)) {\n    throw new Error('The data field must be HEX encoded data.');\n  }\n  // allow both\n  if (options.gas || options.gasLimit) {\n    options.gas = options.gas || options.gasLimit;\n  }\n  if (options.maxPriorityFeePerGas || options.maxFeePerGas) {\n    delete options.gasPrice;\n  }\n  ['gasPrice', 'gas', 'value', 'maxPriorityFeePerGas', 'maxFeePerGas', 'nonce'].filter(function (key) {\n    return options[key] !== undefined;\n  }).forEach(function (key) {\n    options[key] = utils.numberToHex(options[key]);\n  });\n  return options;\n};\n/**\n * Formats the input of a transaction and converts all values to HEX\n *\n * @method inputCallFormatter\n * @param {Object} transaction options\n * @returns object\n */\nvar inputCallFormatter = function (options) {\n  options = _txInputFormatter(options);\n  var from = options.from || (this ? this.defaultAccount : null);\n  if (from) {\n    options.from = inputAddressFormatter(from);\n  }\n  return options;\n};\n/**\n * Formats the input of a transaction and converts all values to HEX\n *\n * @method inputTransactionFormatter\n * @param {Object} options\n * @returns object\n */\nvar inputTransactionFormatter = function (options) {\n  options = _txInputFormatter(options);\n  // check from, only if not number, or object\n  if (!(typeof options.from === 'number') && !(!!options.from && typeof options.from === 'object')) {\n    options.from = options.from || (this ? this.defaultAccount : null);\n    if (!options.from && !(typeof options.from === 'number')) {\n      throw new Error('The send transactions \"from\" field must be defined!');\n    }\n    options.from = inputAddressFormatter(options.from);\n  }\n  return options;\n};\n/**\n * Hex encodes the data passed to eth_sign and personal_sign\n *\n * @method inputSignFormatter\n * @param {String} data\n * @returns {String}\n */\nvar inputSignFormatter = function (data) {\n  return utils.isHexStrict(data) ? data : utils.utf8ToHex(data);\n};\n/**\n * Formats the output of a transaction to its proper values\n *\n * @method outputTransactionFormatter\n * @param {Object} tx\n * @returns {Object}\n */\nvar outputTransactionFormatter = function (tx, hexFormat) {\n  if (!hexFormat) {\n    if (tx.blockNumber !== null) tx.blockNumber = utils.hexToNumber(tx.blockNumber);\n    if (tx.transactionIndex !== null) tx.transactionIndex = utils.hexToNumber(tx.transactionIndex);\n    tx.nonce = utils.hexToNumber(tx.nonce);\n    tx.gas = utils.hexToNumber(tx.gas);\n    if (tx.type) tx.type = utils.hexToNumber(tx.type);\n  }\n  if (tx.gasPrice) tx.gasPrice = outputBigNumberFormatter(tx.gasPrice);\n  if (tx.maxFeePerGas) tx.maxFeePerGas = outputBigNumberFormatter(tx.maxFeePerGas);\n  if (tx.maxPriorityFeePerGas) tx.maxPriorityFeePerGas = outputBigNumberFormatter(tx.maxPriorityFeePerGas);\n  tx.value = outputBigNumberFormatter(tx.value);\n  if (tx.to && utils.isAddress(tx.to)) {\n    // tx.to could be `0x0` or `null` while contract creation\n    tx.to = utils.toChecksumAddress(tx.to);\n  } else {\n    tx.to = null; // set to `null` if invalid address\n  }\n\n  if (tx.from) {\n    tx.from = utils.toChecksumAddress(tx.from);\n  }\n  return tx;\n};\n/**\n * Formats the output of a transaction receipt to its proper values\n *\n * @method outputTransactionReceiptFormatter\n * @param {Object} receipt\n * @returns {Object}\n */\nvar outputTransactionReceiptFormatter = function (receipt) {\n  if (typeof receipt !== 'object') {\n    throw new Error('Received receipt is invalid: ' + receipt);\n  }\n  if (!this.hexFormat) {\n    if (receipt.blockNumber !== null) receipt.blockNumber = utils.hexToNumber(receipt.blockNumber);\n    if (receipt.transactionIndex !== null) receipt.transactionIndex = utils.hexToNumber(receipt.transactionIndex);\n    receipt.cumulativeGasUsed = utils.hexToNumber(receipt.cumulativeGasUsed);\n    receipt.gasUsed = utils.hexToNumber(receipt.gasUsed);\n    if (receipt.effectiveGasPrice) {\n      receipt.effectiveGasPrice = utils.hexToNumber(receipt.effectiveGasPrice);\n    }\n  }\n  if (Array.isArray(receipt.logs)) {\n    receipt.logs = receipt.logs.map(outputLogFormatter);\n  }\n  if (receipt.contractAddress) {\n    receipt.contractAddress = utils.toChecksumAddress(receipt.contractAddress);\n  }\n  if (typeof receipt.status !== 'undefined' && receipt.status !== null) {\n    receipt.status = Boolean(parseInt(receipt.status));\n  }\n  return receipt;\n};\n/**\n * Formats the output of a block to its proper values\n *\n * @method outputBlockFormatter\n * @param {Object} block\n * @returns {Object}\n */\nvar outputBlockFormatter = function (block, hexFormat) {\n  if (!hexFormat) {\n    // transform to number\n    block.gasLimit = utils.hexToNumber(block.gasLimit);\n    block.gasUsed = utils.hexToNumber(block.gasUsed);\n    block.size = utils.hexToNumber(block.size);\n    block.timestamp = utils.hexToNumber(block.timestamp);\n    if (block.number !== null) block.number = utils.hexToNumber(block.number);\n  }\n  if (block.difficulty) block.difficulty = outputBigNumberFormatter(block.difficulty);\n  if (block.totalDifficulty) block.totalDifficulty = outputBigNumberFormatter(block.totalDifficulty);\n  if (Array.isArray(block.transactions)) {\n    block.transactions.forEach(function (item) {\n      if (!(typeof item === 'string')) return outputTransactionFormatter(item, hexFormat);\n    });\n  }\n  if (block.miner) block.miner = utils.toChecksumAddress(block.miner);\n  if (block.baseFeePerGas) block.baseFeePerGas = utils.hexToNumber(block.baseFeePerGas);\n  return block;\n};\n/**\n * Formats the input of a log\n *\n * @method inputLogFormatter\n * @param {Object} log object\n * @returns {Object} log\n */\nvar inputLogFormatter = function (options) {\n  var toTopic = function (value) {\n    if (value === null || typeof value === 'undefined') return null;\n    value = String(value);\n    if (value.indexOf('0x') === 0) return value;else return utils.fromUtf8(value);\n  };\n  if (options === undefined) options = {};\n  // If options !== undefined, don't blow out existing data\n  if (options.fromBlock === undefined) options = {\n    ...options,\n    fromBlock: 'latest'\n  };\n  if (options.fromBlock || options.fromBlock === 0) options.fromBlock = inputBlockNumberFormatter(options.fromBlock);\n  if (options.toBlock || options.toBlock === 0) options.toBlock = inputBlockNumberFormatter(options.toBlock);\n  // make sure topics, get converted to hex\n  options.topics = options.topics || [];\n  options.topics = options.topics.map(function (topic) {\n    return Array.isArray(topic) ? topic.map(toTopic) : toTopic(topic);\n  });\n  toTopic = null;\n  if (options.address) {\n    options.address = Array.isArray(options.address) ? options.address.map(function (addr) {\n      return inputAddressFormatter(addr);\n    }) : inputAddressFormatter(options.address);\n  }\n  return options;\n};\n/**\n * Formats the output of a log\n *\n * @method outputLogFormatter\n * @param {Object} log object\n * @returns {Object} log\n */\nvar outputLogFormatter = function (log) {\n  // generate a custom log id\n  if (typeof log.blockHash === 'string' && typeof log.transactionHash === 'string' && typeof log.logIndex === 'string') {\n    var shaId = utils.sha3(log.blockHash.replace('0x', '') + log.transactionHash.replace('0x', '') + log.logIndex.replace('0x', ''));\n    log.id = 'log_' + shaId.replace('0x', '').slice(0, 8);\n  } else if (!log.id) {\n    log.id = null;\n  }\n  if (log.blockNumber !== null) log.blockNumber = utils.hexToNumber(log.blockNumber);\n  if (log.transactionIndex !== null) log.transactionIndex = utils.hexToNumber(log.transactionIndex);\n  if (log.logIndex !== null) log.logIndex = utils.hexToNumber(log.logIndex);\n  if (log.address) {\n    log.address = utils.toChecksumAddress(log.address);\n  }\n  return log;\n};\n/**\n * Formats the input of a whisper post and converts all values to HEX\n *\n * @method inputPostFormatter\n * @param {Object} transaction object\n * @returns {Object}\n */\nvar inputPostFormatter = function (post) {\n  // post.payload = utils.toHex(post.payload);\n  if (post.ttl) post.ttl = utils.numberToHex(post.ttl);\n  if (post.workToProve) post.workToProve = utils.numberToHex(post.workToProve);\n  if (post.priority) post.priority = utils.numberToHex(post.priority);\n  // fallback\n  if (!Array.isArray(post.topics)) {\n    post.topics = post.topics ? [post.topics] : [];\n  }\n  // format the following options\n  post.topics = post.topics.map(function (topic) {\n    // convert only if not hex\n    return topic.indexOf('0x') === 0 ? topic : utils.fromUtf8(topic);\n  });\n  return post;\n};\n/**\n * Formats the output of a received post message\n *\n * @method outputPostFormatter\n * @param {Object}\n * @returns {Object}\n */\nvar outputPostFormatter = function (post) {\n  post.expiry = utils.hexToNumber(post.expiry);\n  post.sent = utils.hexToNumber(post.sent);\n  post.ttl = utils.hexToNumber(post.ttl);\n  post.workProved = utils.hexToNumber(post.workProved);\n  // post.payloadRaw = post.payload;\n  // post.payload = utils.hexToAscii(post.payload);\n  // if (utils.isJson(post.payload)) {\n  //     post.payload = JSON.parse(post.payload);\n  // }\n  // format the following options\n  if (!post.topics) {\n    post.topics = [];\n  }\n  post.topics = post.topics.map(function (topic) {\n    return utils.toUtf8(topic);\n  });\n  return post;\n};\nvar inputAddressFormatter = function (address) {\n  var iban = new Iban(address);\n  if (iban.isValid() && iban.isDirect()) {\n    return iban.toAddress().toLowerCase();\n  } else if (utils.isAddress(address)) {\n    return '0x' + address.toLowerCase().replace('0x', '');\n  }\n  throw new Error(`Provided address ${address} is invalid, the capitalization checksum test failed, or it's an indirect IBAN address which can't be converted.`);\n};\nvar outputSyncingFormatter = function (result) {\n  result.startingBlock = utils.hexToNumber(result.startingBlock);\n  result.currentBlock = utils.hexToNumber(result.currentBlock);\n  result.highestBlock = utils.hexToNumber(result.highestBlock);\n  if (result.knownStates) {\n    result.knownStates = utils.hexToNumber(result.knownStates);\n    result.pulledStates = utils.hexToNumber(result.pulledStates);\n  }\n  return result;\n};\nmodule.exports = {\n  inputDefaultBlockNumberFormatter: inputDefaultBlockNumberFormatter,\n  inputBlockNumberFormatter: inputBlockNumberFormatter,\n  inputCallFormatter: inputCallFormatter,\n  inputTransactionFormatter: inputTransactionFormatter,\n  inputAddressFormatter: inputAddressFormatter,\n  inputPostFormatter: inputPostFormatter,\n  inputLogFormatter: inputLogFormatter,\n  inputSignFormatter: inputSignFormatter,\n  inputStorageKeysFormatter: inputStorageKeysFormatter,\n  outputProofFormatter: outputProofFormatter,\n  outputBigNumberFormatter: outputBigNumberFormatter,\n  outputTransactionFormatter: outputTransactionFormatter,\n  outputTransactionReceiptFormatter: outputTransactionReceiptFormatter,\n  outputBlockFormatter: outputBlockFormatter,\n  outputLogFormatter: outputLogFormatter,\n  outputPostFormatter: outputPostFormatter,\n  outputSyncingFormatter: outputSyncingFormatter\n};","map":{"version":3,"names":["utils","require","Iban","inputStorageKeysFormatter","keys","map","numberToHex","outputProofFormatter","proof","address","toChecksumAddress","nonce","hexToNumberString","balance","outputBigNumberFormatter","number","toBN","toString","isPredefinedBlockNumber","blockNumber","includes","inputDefaultBlockNumberFormatter","undefined","inputBlockNumberFormatter","defaultBlock","isHexStrict","toLowerCase","_txInputFormatter","options","to","inputAddressFormatter","data","input","Error","startsWith","isHex","gas","gasLimit","maxPriorityFeePerGas","maxFeePerGas","gasPrice","filter","key","forEach","inputCallFormatter","from","defaultAccount","inputTransactionFormatter","inputSignFormatter","utf8ToHex","outputTransactionFormatter","tx","hexFormat","hexToNumber","transactionIndex","type","value","isAddress","outputTransactionReceiptFormatter","receipt","cumulativeGasUsed","gasUsed","effectiveGasPrice","Array","isArray","logs","outputLogFormatter","contractAddress","status","Boolean","parseInt","outputBlockFormatter","block","size","timestamp","difficulty","totalDifficulty","transactions","item","miner","baseFeePerGas","inputLogFormatter","toTopic","String","indexOf","fromUtf8","fromBlock","toBlock","topics","topic","addr","log","blockHash","transactionHash","logIndex","shaId","sha3","replace","id","slice","inputPostFormatter","post","ttl","workToProve","priority","outputPostFormatter","expiry","sent","workProved","toUtf8","iban","isValid","isDirect","toAddress","outputSyncingFormatter","result","startingBlock","currentBlock","highestBlock","knownStates","pulledStates","module","exports"],"sources":["C:/Users/jack/git/hackathon/starter-files/node_modules/web3-core-helpers/lib/formatters.js"],"sourcesContent":["/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file formatters.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\n\"use strict\";\nvar utils = require('web3-utils');\nvar Iban = require('web3-eth-iban');\n/**\n * Will format the given storage key array values to hex strings.\n *\n * @method inputStorageKeysFormatter\n *\n * @param {Array<Number|String|BN|BigNumber>} keys\n *\n * @returns {Array<String>}\n */\nvar inputStorageKeysFormatter = function (keys) {\n    return keys.map(utils.numberToHex);\n};\n/**\n * Will format the given proof response from the node.\n *\n * @method outputProofFormatter\n *\n * @param {object} proof\n *\n * @returns {object}\n */\nvar outputProofFormatter = function (proof) {\n    proof.address = utils.toChecksumAddress(proof.address);\n    proof.nonce = utils.hexToNumberString(proof.nonce);\n    proof.balance = utils.hexToNumberString(proof.balance);\n    return proof;\n};\n/**\n * Should the format output to a big number\n *\n * @method outputBigNumberFormatter\n *\n * @param {String|Number|BigNumber|BN} number\n *\n * @returns {BN} object\n */\nvar outputBigNumberFormatter = function (number) {\n    return utils.toBN(number).toString(10);\n};\n/**\n * Returns true if the given blockNumber is 'latest', 'pending', 'earliest, 'finalized' or 'safe'\n *\n * @method isPredefinedBlockNumber\n *\n * @param {String} blockNumber\n *\n * @returns {Boolean}\n */\nvar isPredefinedBlockNumber = function (blockNumber) {\n    return ['latest', 'pending', 'earliest', 'finalized', 'safe'].includes(blockNumber);\n};\n/**\n * Returns the given block number as hex string or does return the defaultBlock property of the current module\n *\n * @method inputDefaultBlockNumberFormatter\n *\n * @param {String|Number|BN|BigNumber} blockNumber\n *\n * @returns {String}\n */\nvar inputDefaultBlockNumberFormatter = function (blockNumber) {\n    if (this && (blockNumber === undefined || blockNumber === null)) {\n        return inputBlockNumberFormatter(this.defaultBlock);\n    }\n    return inputBlockNumberFormatter(blockNumber);\n};\n/**\n * Returns the given block number as hex string or the predefined block number 'latest', 'pending', 'earliest', 'finalized', 'safe', 'genesis'\n *\n * @param {String|Number|BN|BigNumber} blockNumber\n *\n * @returns {String}\n */\nvar inputBlockNumberFormatter = function (blockNumber) {\n    if (blockNumber === undefined) {\n        return undefined;\n    }\n    if (isPredefinedBlockNumber(blockNumber)) {\n        return blockNumber;\n    }\n    if (blockNumber === 'genesis') {\n        return '0x0';\n    }\n    return (utils.isHexStrict(blockNumber)) ? ((typeof blockNumber === 'string') ? blockNumber.toLowerCase() : blockNumber) : utils.numberToHex(blockNumber);\n};\n/**\n * Formats the input of a transaction and converts all values to HEX\n *\n * @method _txInputFormatter\n * @param {Object} transaction options\n * @returns object\n */\nvar _txInputFormatter = function (options) {\n    if (options.to) { // it might be contract creation\n        options.to = inputAddressFormatter(options.to);\n    }\n    if (options.data && options.input) {\n        throw new Error('You can\\'t have \"data\" and \"input\" as properties of transactions at the same time, please use either \"data\" or \"input\" instead.');\n    }\n    if (!options.data && options.input) {\n        options.data = options.input;\n        delete options.input;\n    }\n    if (options.data && !options.data.startsWith('0x')) {\n        options.data = '0x' + options.data;\n    }\n    if (options.data && !utils.isHex(options.data)) {\n        throw new Error('The data field must be HEX encoded data.');\n    }\n    // allow both\n    if (options.gas || options.gasLimit) {\n        options.gas = options.gas || options.gasLimit;\n    }\n    if (options.maxPriorityFeePerGas || options.maxFeePerGas) {\n        delete options.gasPrice;\n    }\n    ['gasPrice', 'gas', 'value', 'maxPriorityFeePerGas', 'maxFeePerGas', 'nonce'].filter(function (key) {\n        return options[key] !== undefined;\n    }).forEach(function (key) {\n        options[key] = utils.numberToHex(options[key]);\n    });\n    return options;\n};\n/**\n * Formats the input of a transaction and converts all values to HEX\n *\n * @method inputCallFormatter\n * @param {Object} transaction options\n * @returns object\n */\nvar inputCallFormatter = function (options) {\n    options = _txInputFormatter(options);\n    var from = options.from || (this ? this.defaultAccount : null);\n    if (from) {\n        options.from = inputAddressFormatter(from);\n    }\n    return options;\n};\n/**\n * Formats the input of a transaction and converts all values to HEX\n *\n * @method inputTransactionFormatter\n * @param {Object} options\n * @returns object\n */\nvar inputTransactionFormatter = function (options) {\n    options = _txInputFormatter(options);\n    // check from, only if not number, or object\n    if (!(typeof options.from === 'number') && !(!!options.from && typeof options.from === 'object')) {\n        options.from = options.from || (this ? this.defaultAccount : null);\n        if (!options.from && !(typeof options.from === 'number')) {\n            throw new Error('The send transactions \"from\" field must be defined!');\n        }\n        options.from = inputAddressFormatter(options.from);\n    }\n    return options;\n};\n/**\n * Hex encodes the data passed to eth_sign and personal_sign\n *\n * @method inputSignFormatter\n * @param {String} data\n * @returns {String}\n */\nvar inputSignFormatter = function (data) {\n    return (utils.isHexStrict(data)) ? data : utils.utf8ToHex(data);\n};\n/**\n * Formats the output of a transaction to its proper values\n *\n * @method outputTransactionFormatter\n * @param {Object} tx\n * @returns {Object}\n */\nvar outputTransactionFormatter = function (tx, hexFormat) {\n    if (!hexFormat) {\n        if (tx.blockNumber !== null)\n            tx.blockNumber = utils.hexToNumber(tx.blockNumber);\n        if (tx.transactionIndex !== null)\n            tx.transactionIndex = utils.hexToNumber(tx.transactionIndex);\n        tx.nonce = utils.hexToNumber(tx.nonce);\n        tx.gas = utils.hexToNumber(tx.gas);\n        if (tx.type)\n            tx.type = utils.hexToNumber(tx.type);\n    }\n    if (tx.gasPrice)\n        tx.gasPrice = outputBigNumberFormatter(tx.gasPrice);\n    if (tx.maxFeePerGas)\n        tx.maxFeePerGas = outputBigNumberFormatter(tx.maxFeePerGas);\n    if (tx.maxPriorityFeePerGas)\n        tx.maxPriorityFeePerGas = outputBigNumberFormatter(tx.maxPriorityFeePerGas);\n    tx.value = outputBigNumberFormatter(tx.value);\n    if (tx.to && utils.isAddress(tx.to)) { // tx.to could be `0x0` or `null` while contract creation\n        tx.to = utils.toChecksumAddress(tx.to);\n    }\n    else {\n        tx.to = null; // set to `null` if invalid address\n    }\n    if (tx.from) {\n        tx.from = utils.toChecksumAddress(tx.from);\n    }\n    return tx;\n};\n/**\n * Formats the output of a transaction receipt to its proper values\n *\n * @method outputTransactionReceiptFormatter\n * @param {Object} receipt\n * @returns {Object}\n */\nvar outputTransactionReceiptFormatter = function (receipt) {\n    if (typeof receipt !== 'object') {\n        throw new Error('Received receipt is invalid: ' + receipt);\n    }\n    if (!this.hexFormat) {\n        if (receipt.blockNumber !== null)\n            receipt.blockNumber = utils.hexToNumber(receipt.blockNumber);\n        if (receipt.transactionIndex !== null)\n            receipt.transactionIndex = utils.hexToNumber(receipt.transactionIndex);\n        receipt.cumulativeGasUsed = utils.hexToNumber(receipt.cumulativeGasUsed);\n        receipt.gasUsed = utils.hexToNumber(receipt.gasUsed);\n        if (receipt.effectiveGasPrice) {\n            receipt.effectiveGasPrice = utils.hexToNumber(receipt.effectiveGasPrice);\n        }\n    }\n    if (Array.isArray(receipt.logs)) {\n        receipt.logs = receipt.logs.map(outputLogFormatter);\n    }\n    if (receipt.contractAddress) {\n        receipt.contractAddress = utils.toChecksumAddress(receipt.contractAddress);\n    }\n    if (typeof receipt.status !== 'undefined' && receipt.status !== null) {\n        receipt.status = Boolean(parseInt(receipt.status));\n    }\n    return receipt;\n};\n/**\n * Formats the output of a block to its proper values\n *\n * @method outputBlockFormatter\n * @param {Object} block\n * @returns {Object}\n */\nvar outputBlockFormatter = function (block, hexFormat) {\n    if (!hexFormat) {\n        // transform to number\n        block.gasLimit = utils.hexToNumber(block.gasLimit);\n        block.gasUsed = utils.hexToNumber(block.gasUsed);\n        block.size = utils.hexToNumber(block.size);\n        block.timestamp = utils.hexToNumber(block.timestamp);\n        if (block.number !== null)\n            block.number = utils.hexToNumber(block.number);\n    }\n    if (block.difficulty)\n        block.difficulty = outputBigNumberFormatter(block.difficulty);\n    if (block.totalDifficulty)\n        block.totalDifficulty = outputBigNumberFormatter(block.totalDifficulty);\n    if (Array.isArray(block.transactions)) {\n        block.transactions.forEach(function (item) {\n            if (!(typeof item === 'string'))\n                return outputTransactionFormatter(item, hexFormat);\n        });\n    }\n    if (block.miner)\n        block.miner = utils.toChecksumAddress(block.miner);\n    if (block.baseFeePerGas)\n        block.baseFeePerGas = utils.hexToNumber(block.baseFeePerGas);\n    return block;\n};\n/**\n * Formats the input of a log\n *\n * @method inputLogFormatter\n * @param {Object} log object\n * @returns {Object} log\n */\nvar inputLogFormatter = function (options) {\n    var toTopic = function (value) {\n        if (value === null || typeof value === 'undefined')\n            return null;\n        value = String(value);\n        if (value.indexOf('0x') === 0)\n            return value;\n        else\n            return utils.fromUtf8(value);\n    };\n    if (options === undefined)\n        options = {};\n    // If options !== undefined, don't blow out existing data\n    if (options.fromBlock === undefined)\n        options = { ...options, fromBlock: 'latest' };\n    if (options.fromBlock || options.fromBlock === 0)\n        options.fromBlock = inputBlockNumberFormatter(options.fromBlock);\n    if (options.toBlock || options.toBlock === 0)\n        options.toBlock = inputBlockNumberFormatter(options.toBlock);\n    // make sure topics, get converted to hex\n    options.topics = options.topics || [];\n    options.topics = options.topics.map(function (topic) {\n        return (Array.isArray(topic)) ? topic.map(toTopic) : toTopic(topic);\n    });\n    toTopic = null;\n    if (options.address) {\n        options.address = (Array.isArray(options.address)) ? options.address.map(function (addr) {\n            return inputAddressFormatter(addr);\n        }) : inputAddressFormatter(options.address);\n    }\n    return options;\n};\n/**\n * Formats the output of a log\n *\n * @method outputLogFormatter\n * @param {Object} log object\n * @returns {Object} log\n */\nvar outputLogFormatter = function (log) {\n    // generate a custom log id\n    if (typeof log.blockHash === 'string' &&\n        typeof log.transactionHash === 'string' &&\n        typeof log.logIndex === 'string') {\n        var shaId = utils.sha3(log.blockHash.replace('0x', '') + log.transactionHash.replace('0x', '') + log.logIndex.replace('0x', ''));\n        log.id = 'log_' + shaId.replace('0x', '').slice(0, 8);\n    }\n    else if (!log.id) {\n        log.id = null;\n    }\n    if (log.blockNumber !== null)\n        log.blockNumber = utils.hexToNumber(log.blockNumber);\n    if (log.transactionIndex !== null)\n        log.transactionIndex = utils.hexToNumber(log.transactionIndex);\n    if (log.logIndex !== null)\n        log.logIndex = utils.hexToNumber(log.logIndex);\n    if (log.address) {\n        log.address = utils.toChecksumAddress(log.address);\n    }\n    return log;\n};\n/**\n * Formats the input of a whisper post and converts all values to HEX\n *\n * @method inputPostFormatter\n * @param {Object} transaction object\n * @returns {Object}\n */\nvar inputPostFormatter = function (post) {\n    // post.payload = utils.toHex(post.payload);\n    if (post.ttl)\n        post.ttl = utils.numberToHex(post.ttl);\n    if (post.workToProve)\n        post.workToProve = utils.numberToHex(post.workToProve);\n    if (post.priority)\n        post.priority = utils.numberToHex(post.priority);\n    // fallback\n    if (!Array.isArray(post.topics)) {\n        post.topics = post.topics ? [post.topics] : [];\n    }\n    // format the following options\n    post.topics = post.topics.map(function (topic) {\n        // convert only if not hex\n        return (topic.indexOf('0x') === 0) ? topic : utils.fromUtf8(topic);\n    });\n    return post;\n};\n/**\n * Formats the output of a received post message\n *\n * @method outputPostFormatter\n * @param {Object}\n * @returns {Object}\n */\nvar outputPostFormatter = function (post) {\n    post.expiry = utils.hexToNumber(post.expiry);\n    post.sent = utils.hexToNumber(post.sent);\n    post.ttl = utils.hexToNumber(post.ttl);\n    post.workProved = utils.hexToNumber(post.workProved);\n    // post.payloadRaw = post.payload;\n    // post.payload = utils.hexToAscii(post.payload);\n    // if (utils.isJson(post.payload)) {\n    //     post.payload = JSON.parse(post.payload);\n    // }\n    // format the following options\n    if (!post.topics) {\n        post.topics = [];\n    }\n    post.topics = post.topics.map(function (topic) {\n        return utils.toUtf8(topic);\n    });\n    return post;\n};\nvar inputAddressFormatter = function (address) {\n    var iban = new Iban(address);\n    if (iban.isValid() && iban.isDirect()) {\n        return iban.toAddress().toLowerCase();\n    }\n    else if (utils.isAddress(address)) {\n        return '0x' + address.toLowerCase().replace('0x', '');\n    }\n    throw new Error(`Provided address ${address} is invalid, the capitalization checksum test failed, or it's an indirect IBAN address which can't be converted.`);\n};\nvar outputSyncingFormatter = function (result) {\n    result.startingBlock = utils.hexToNumber(result.startingBlock);\n    result.currentBlock = utils.hexToNumber(result.currentBlock);\n    result.highestBlock = utils.hexToNumber(result.highestBlock);\n    if (result.knownStates) {\n        result.knownStates = utils.hexToNumber(result.knownStates);\n        result.pulledStates = utils.hexToNumber(result.pulledStates);\n    }\n    return result;\n};\nmodule.exports = {\n    inputDefaultBlockNumberFormatter: inputDefaultBlockNumberFormatter,\n    inputBlockNumberFormatter: inputBlockNumberFormatter,\n    inputCallFormatter: inputCallFormatter,\n    inputTransactionFormatter: inputTransactionFormatter,\n    inputAddressFormatter: inputAddressFormatter,\n    inputPostFormatter: inputPostFormatter,\n    inputLogFormatter: inputLogFormatter,\n    inputSignFormatter: inputSignFormatter,\n    inputStorageKeysFormatter: inputStorageKeysFormatter,\n    outputProofFormatter: outputProofFormatter,\n    outputBigNumberFormatter: outputBigNumberFormatter,\n    outputTransactionFormatter: outputTransactionFormatter,\n    outputTransactionReceiptFormatter: outputTransactionReceiptFormatter,\n    outputBlockFormatter: outputBlockFormatter,\n    outputLogFormatter: outputLogFormatter,\n    outputPostFormatter: outputPostFormatter,\n    outputSyncingFormatter: outputSyncingFormatter\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}