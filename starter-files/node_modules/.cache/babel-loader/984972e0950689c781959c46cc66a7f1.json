{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport assertNever from \"assert-never\";\nimport { delay, promisify } from \"../util/promises\";\nvar ALCHEMY_DISALLOWED_METHODS = [\"eth_accounts\", \"eth_sendTransaction\", \"eth_sign\", \"eth_signTypedData_v3\", \"eth_signTypedData\"];\nvar ALCHEMY_DISALLOWED_PREFIXES = [\"personal\"];\nexport function makeJsonRpcPayloadSender(alchemySendJsonRpc, config) {\n  // Copy middlewares from config.\n  var middlewares = [];\n  config.jsonRpcSenderMiddlewares.forEach(function (m) {\n    return middlewares.push(m);\n  });\n  var currentWriteProvider = config.writeProvider;\n  middlewares.push(function (payload) {\n    var disallowedMethod = getDisallowedMethod(payload);\n    if (!disallowedMethod) {\n      try {\n        return sendJsonRpcWithRetries(payload, alchemySendJsonRpc, config);\n      } catch (alchemyError) {\n        // Fallback to write provider, but if both fail throw the error from\n        // Alchemy.\n        if (!currentWriteProvider) {\n          throw alchemyError;\n        }\n        try {\n          return sendJsonRpcWithProvider(currentWriteProvider, payload);\n        } catch (_a) {\n          throw alchemyError;\n        }\n      }\n    } else {\n      if (!currentWriteProvider) {\n        throw new Error(\"No provider available for method \\\"\" + disallowedMethod + \"\\\"\");\n      }\n      return sendJsonRpcWithProvider(currentWriteProvider, payload);\n    }\n  });\n  var sendJsonRpcPayload = function (payload) {\n    var getNext = function (i) {\n      var middleware = middlewares[i];\n      return function () {\n        return middleware(payload, getNext(i + 1));\n      };\n    };\n    return getNext(0)();\n  };\n  function setWriteProvider(writeProvider) {\n    currentWriteProvider = writeProvider !== null && writeProvider !== void 0 ? writeProvider : null;\n  }\n  return {\n    sendJsonRpcPayload: sendJsonRpcPayload,\n    setWriteProvider: setWriteProvider\n  };\n}\nfunction sendJsonRpcWithProvider(provider, payload) {\n  var anyProvider = provider;\n  var sendMethod = (anyProvider.sendAsync ? anyProvider.sendAsync : anyProvider.send).bind(anyProvider);\n  return promisify(function (callback) {\n    return sendMethod(payload, callback);\n  });\n}\nfunction getDisallowedMethod(payload) {\n  var payloads = Array.isArray(payload) ? payload : [payload];\n  // Check if the payload method is a disallowed method or starts with a\n  // disallowed prefix.\n  var disallowedRequest = payloads.find(function (p) {\n    return ALCHEMY_DISALLOWED_METHODS.indexOf(p.method) >= 0 || ALCHEMY_DISALLOWED_PREFIXES.some(function (prefix) {\n      return p.method.startsWith(prefix);\n    });\n  }) || undefined;\n  return disallowedRequest && disallowedRequest.method;\n}\nfunction sendJsonRpcWithRetries(payload, alchemySendJsonRpc, _a) {\n  var maxRetries = _a.maxRetries,\n    retryInterval = _a.retryInterval,\n    retryJitter = _a.retryJitter;\n  return __awaiter(this, void 0, void 0, function () {\n    var i, result, status_1, message, statusString;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          i = 0;\n          _b.label = 1;\n        case 1:\n          if (!(i < maxRetries + 1)) return [3 /*break*/, 5];\n          return [4 /*yield*/, alchemySendJsonRpc(payload)];\n        case 2:\n          result = _b.sent();\n          switch (result.type) {\n            case \"jsonrpc\":\n              return [2 /*return*/, result.response];\n            case \"rateLimit\":\n              break;\n            case \"networkError\":\n              {\n                status_1 = result.status, message = result.message;\n                statusString = status_1 !== 0 ? \"(\" + status_1 + \") \" : \"\";\n                throw new Error(statusString + \" \" + message);\n              }\n            default:\n              return [2 /*return*/, assertNever(result)];\n          }\n          return [4 /*yield*/, delay(retryInterval + (retryJitter * Math.random() | 0))];\n        case 3:\n          _b.sent();\n          _b.label = 4;\n        case 4:\n          i++;\n          return [3 /*break*/, 1];\n        case 5:\n          throw new Error(\"Rate limited for \" + (maxRetries + 1) + \" consecutive attempts.\");\n      }\n    });\n  });\n}","map":{"version":3,"names":["assertNever","delay","promisify","ALCHEMY_DISALLOWED_METHODS","ALCHEMY_DISALLOWED_PREFIXES","makeJsonRpcPayloadSender","alchemySendJsonRpc","config","middlewares","jsonRpcSenderMiddlewares","forEach","m","push","currentWriteProvider","writeProvider","payload","disallowedMethod","getDisallowedMethod","sendJsonRpcWithRetries","alchemyError","sendJsonRpcWithProvider","_a","Error","sendJsonRpcPayload","getNext","i","middleware","setWriteProvider","provider","anyProvider","sendMethod","sendAsync","send","bind","callback","payloads","Array","isArray","disallowedRequest","find","p","indexOf","method","some","prefix","startsWith","undefined","maxRetries","retryInterval","retryJitter","result","_b","sent","type","response","status_1","status","message","statusString","Math","random"],"sources":["../../../src/web3-adapter/sendJsonRpcPayload.ts"],"sourcesContent":["import assertNever from \"assert-never\";\nimport {\n  FullConfig,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  JsonRpcSenderMiddleware,\n  Provider,\n  SingleOrBatchRequest,\n  SingleOrBatchResponse,\n} from \"../types\";\nimport { delay, promisify } from \"../util/promises\";\nimport { AlchemySendJsonRpcFunction } from \"./alchemySend\";\n\nconst ALCHEMY_DISALLOWED_METHODS: string[] = [\n  \"eth_accounts\",\n  \"eth_sendTransaction\",\n  \"eth_sign\",\n  \"eth_signTypedData_v3\",\n  \"eth_signTypedData\",\n];\n\nconst ALCHEMY_DISALLOWED_PREFIXES: string[] = [\"personal\"];\n\nexport interface JsonRpcPayloadSender {\n  sendJsonRpcPayload: SendJsonRpcPayloadFunction;\n  setWriteProvider(writeProvider: Provider | null | undefined): void;\n}\n\nexport interface SendJsonRpcPayloadFunction {\n  (payload: JsonRpcRequest): Promise<JsonRpcResponse>;\n  (payload: SingleOrBatchRequest): Promise<SingleOrBatchResponse>;\n}\n\nexport function makeJsonRpcPayloadSender(\n  alchemySendJsonRpc: AlchemySendJsonRpcFunction,\n  config: FullConfig,\n): JsonRpcPayloadSender {\n  // Copy middlewares from config.\n  const middlewares: JsonRpcSenderMiddleware[] = [];\n  config.jsonRpcSenderMiddlewares.forEach((m) => middlewares.push(m));\n\n  let currentWriteProvider = config.writeProvider;\n  middlewares.push((payload) => {\n    const disallowedMethod = getDisallowedMethod(payload);\n    if (!disallowedMethod) {\n      try {\n        return sendJsonRpcWithRetries(payload, alchemySendJsonRpc, config);\n      } catch (alchemyError) {\n        // Fallback to write provider, but if both fail throw the error from\n        // Alchemy.\n        if (!currentWriteProvider) {\n          throw alchemyError;\n        }\n        try {\n          return sendJsonRpcWithProvider(currentWriteProvider, payload);\n        } catch {\n          throw alchemyError;\n        }\n      }\n    } else {\n      if (!currentWriteProvider) {\n        throw new Error(\n          `No provider available for method \"${disallowedMethod}\"`,\n        );\n      }\n      return sendJsonRpcWithProvider(currentWriteProvider, payload);\n    }\n  });\n\n  const sendJsonRpcPayload = (\n    payload: SingleOrBatchRequest,\n  ): Promise<SingleOrBatchResponse> => {\n    const getNext = (i: number) => {\n      const middleware = middlewares[i];\n      return () => middleware(payload, getNext(i + 1));\n    };\n    return getNext(0)();\n  };\n\n  function setWriteProvider(writeProvider: Provider | null | undefined) {\n    currentWriteProvider = writeProvider ?? null;\n  }\n\n  return {\n    sendJsonRpcPayload: sendJsonRpcPayload as SendJsonRpcPayloadFunction,\n    setWriteProvider,\n  };\n}\n\nfunction sendJsonRpcWithProvider(\n  provider: Provider,\n  payload: SingleOrBatchRequest,\n): Promise<SingleOrBatchResponse> {\n  const anyProvider: any = provider;\n  const sendMethod = (\n    anyProvider.sendAsync ? anyProvider.sendAsync : anyProvider.send\n  ).bind(anyProvider);\n  return promisify((callback) => sendMethod(payload, callback));\n}\n\nfunction getDisallowedMethod(\n  payload: SingleOrBatchRequest,\n): string | undefined {\n  const payloads = Array.isArray(payload) ? payload : [payload];\n\n  // Check if the payload method is a disallowed method or starts with a\n  // disallowed prefix.\n  const disallowedRequest =\n    payloads.find(\n      (p) =>\n        ALCHEMY_DISALLOWED_METHODS.indexOf(p.method) >= 0 ||\n        ALCHEMY_DISALLOWED_PREFIXES.some((prefix) =>\n          p.method.startsWith(prefix),\n        ),\n    ) || undefined;\n  return disallowedRequest && disallowedRequest.method;\n}\n\nasync function sendJsonRpcWithRetries(\n  payload: SingleOrBatchRequest,\n  alchemySendJsonRpc: AlchemySendJsonRpcFunction,\n  { maxRetries, retryInterval, retryJitter }: FullConfig,\n): Promise<SingleOrBatchResponse> {\n  for (let i = 0; i < maxRetries + 1; i++) {\n    const result = await alchemySendJsonRpc(payload);\n    switch (result.type) {\n      case \"jsonrpc\":\n        return result.response;\n      case \"rateLimit\":\n        break;\n      case \"networkError\": {\n        const { status, message } = result;\n        const statusString = status !== 0 ? `(${status}) ` : \"\";\n        throw new Error(`${statusString} ${message}`);\n      }\n      default:\n        return assertNever(result);\n    }\n    await delay(retryInterval + ((retryJitter * Math.random()) | 0));\n  }\n  throw new Error(`Rate limited for ${maxRetries + 1} consecutive attempts.`);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}