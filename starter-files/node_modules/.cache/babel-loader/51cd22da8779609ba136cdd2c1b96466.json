{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport fetchPonyfill from \"fetch-ponyfill\";\nimport URI from \"urijs\";\nimport { delay } from \"../util/promises\";\nexport function makeRestPayloadSender(_a) {\n  var _this = this;\n  var url = _a.url,\n    config = _a.config;\n  // The rest payload sender only works for alchemy.com http endpoints.\n  var error;\n  if (/^wss?:\\/\\//.test(url)) {\n    error = \"Alchemy rest endpoints are not available via websockets\";\n  }\n  if (!url.includes(\"alchemy\")) {\n    error = \"Alchemy specific rest endpoints are not available with a non Alchemy provider.\";\n  }\n  if (url.includes(\"alchemyapi.io\") && !url.includes(\"eth-\")) {\n    error = \"Alchemy specific rest endpoints on L2 networks are not available with our legacy endpoints on alchemyapi.io. Please switch over to alchemy.com\";\n  }\n  // Don't use the native `URL` class for this. It doesn't work in React Native.\n  var urlObject = new URI(url);\n  var origin = urlObject.origin();\n  var pathname = urlObject.path();\n  var apiKey = pathname.substring(pathname.lastIndexOf(\"/\") + 1);\n  var fetch = fetchPonyfill().fetch;\n  // NFT endpoints are prefixed differently, so the path must be constructed separately\n  var NFT_ENDPOINTS = [\"getNFTs\", \"getNFTMetadata\"];\n  var NFT_PREFIX = \"nft/v2/\";\n  var isNftPath = function (path) {\n    return NFT_ENDPOINTS.includes(path);\n  };\n  var formatNftPath = function (path) {\n    return NFT_PREFIX + apiKey + \"/\" + path;\n  };\n  var sendRestPayload = function (path, payload) {\n    return __awaiter(_this, void 0, void 0, function () {\n      var maxRetries, retryInterval, retryJitter, endpoint, i, response, status_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (error) {\n              throw new Error(error);\n            }\n            maxRetries = config.maxRetries, retryInterval = config.retryInterval, retryJitter = config.retryJitter;\n            if (!(origin && apiKey)) return [3 /*break*/, 6];\n            endpoint = new URI(origin).search(payload).path(isNftPath(path) ? formatNftPath(path) : apiKey + path).toString();\n            i = 0;\n            _a.label = 1;\n          case 1:\n            if (!(i < maxRetries + 1)) return [3 /*break*/, 5];\n            return [4 /*yield*/, fetch(endpoint)];\n          case 2:\n            response = _a.sent();\n            status_1 = response.status;\n            switch (status_1) {\n              case 200:\n                return [2 /*return*/, response.json()];\n              case 429:\n                break;\n              default:\n                throw new Error(response.status + \":\" + response.statusText);\n            }\n            return [4 /*yield*/, delay(retryInterval + (retryJitter * Math.random() | 0))];\n          case 3:\n            _a.sent();\n            _a.label = 4;\n          case 4:\n            i++;\n            return [3 /*break*/, 1];\n          case 5:\n            throw new Error(\"Rate limited for \" + (maxRetries + 1) + \" consecutive attempts.\");\n          case 6:\n            return [2 /*return*/, Promise.resolve()];\n        }\n      });\n    });\n  };\n  return {\n    sendRestPayload: sendRestPayload\n  };\n}","map":{"version":3,"names":["fetchPonyfill","URI","delay","makeRestPayloadSender","_a","_this","url","config","error","test","includes","urlObject","origin","pathname","path","apiKey","substring","lastIndexOf","fetch","NFT_ENDPOINTS","NFT_PREFIX","isNftPath","formatNftPath","sendRestPayload","payload","__awaiter","Error","maxRetries","retryInterval","retryJitter","endpoint","search","toString","i","response","sent","status_1","status","json","statusText","Math","random","Promise","resolve"],"sources":["../../../src/web3-adapter/sendRestPayload.ts"],"sourcesContent":["import fetchPonyfill from \"fetch-ponyfill\";\nimport URI from \"urijs\";\nimport { FullConfig } from \"../types\";\nimport { delay } from \"../util/promises\";\n\nexport interface RestPayloadSender {\n  sendRestPayload: SendRestPayloadFunction;\n}\n\nexport type SendRestPayloadFunction = (\n  path: string,\n  payload: Record<string, any>,\n) => Promise<any>;\n\nexport interface RestPayloadConfig {\n  url: string;\n  config: FullConfig;\n}\n\nexport function makeRestPayloadSender({\n  url,\n  config,\n}: RestPayloadConfig): RestPayloadSender {\n  // The rest payload sender only works for alchemy.com http endpoints.\n  let error: string | undefined;\n  if (/^wss?:\\/\\//.test(url)) {\n    error = \"Alchemy rest endpoints are not available via websockets\";\n  }\n  if (!url.includes(\"alchemy\")) {\n    error =\n      \"Alchemy specific rest endpoints are not available with a non Alchemy provider.\";\n  }\n  if (url.includes(\"alchemyapi.io\") && !url.includes(\"eth-\")) {\n    error =\n      \"Alchemy specific rest endpoints on L2 networks are not available with our legacy endpoints on alchemyapi.io. Please switch over to alchemy.com\";\n  }\n\n  // Don't use the native `URL` class for this. It doesn't work in React Native.\n  const urlObject = new URI(url);\n  const origin = urlObject.origin();\n  const pathname = urlObject.path();\n  const apiKey = pathname.substring(pathname.lastIndexOf(\"/\") + 1);\n\n  const { fetch } = fetchPonyfill();\n\n  // NFT endpoints are prefixed differently, so the path must be constructed separately\n  const NFT_ENDPOINTS = [\"getNFTs\", \"getNFTMetadata\"];\n  const NFT_PREFIX = \"nft/v2/\";\n  const isNftPath = (path: string): boolean => {\n    return NFT_ENDPOINTS.includes(path);\n  };\n  const formatNftPath = (path: string): string => {\n    return NFT_PREFIX + apiKey + \"/\" + path;\n  };\n\n  const sendRestPayload = async (\n    path: string,\n    payload: Record<string, any>,\n  ): Promise<any> => {\n    if (error) {\n      throw new Error(error);\n    }\n    const { maxRetries, retryInterval, retryJitter } = config;\n    if (origin && apiKey) {\n      const endpoint = new URI(origin)\n        .search(payload)\n        .path(isNftPath(path) ? formatNftPath(path) : apiKey + path)\n        .toString();\n      for (let i = 0; i < maxRetries + 1; i++) {\n        const response = await fetch(endpoint);\n        const { status } = response;\n        switch (status) {\n          case 200:\n            return response.json();\n          case 429:\n            break;\n          default:\n            throw new Error(response.status + \":\" + response.statusText);\n        }\n        await delay(retryInterval + ((retryJitter * Math.random()) | 0));\n      }\n      throw new Error(\n        `Rate limited for ${maxRetries + 1} consecutive attempts.`,\n      );\n    }\n    return Promise.resolve();\n  };\n\n  return {\n    sendRestPayload,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}