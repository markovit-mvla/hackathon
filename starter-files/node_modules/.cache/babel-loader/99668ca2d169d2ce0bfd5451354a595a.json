{"ast":null,"code":"import { __assign, __awaiter, __generator, __read, __spreadArray } from \"tslib\";\nimport Web3 from \"web3\";\nimport web3CoreSubscriptions from \"web3-core-subscriptions\";\nimport ABIDecoder from \"web3-eth-abi\";\nimport { toHex } from \"web3-utils\";\nimport { formatBlock } from \"./util/hex\";\nimport { callWhenDone } from \"./util/promises\";\nimport { makeAlchemyContext } from \"./web3-adapter/alchemyContext\";\nimport { patchEnableCustomRPC } from \"./web3-adapter/customRPC\";\nimport { patchEthMaxPriorityFeePerGasMethod } from \"./web3-adapter/eth_maxPriorityFeePerGas\";\nimport { patchEthPrivateTransactionMethods } from \"./web3-adapter/eth_PrivateTransactions\";\nexport * from \"./alchemy-apis/types\";\nvar DEFAULT_MAX_RETRIES = 3;\nvar DEFAULT_RETRY_INTERVAL = 1000;\nvar DEFAULT_RETRY_JITTER = 250;\nvar DEFAULT_CONTRACT_ADDRESS = \"DEFAULT_TOKENS\";\nexport function createAlchemyWeb3(alchemyUrl, config) {\n  var fullConfig = fillInConfigDefaults(config);\n  var _a = makeAlchemyContext(alchemyUrl, fullConfig),\n    provider = _a.provider,\n    jsonRpcSenders = _a.jsonRpcSenders,\n    restSender = _a.restSender,\n    setWriteProvider = _a.setWriteProvider;\n  var alchemyWeb3 = new Web3(provider);\n  alchemyWeb3.setProvider = function () {\n    throw new Error(\"setProvider is not supported in Alchemy Web3. To change the provider used for writes, use setWriteProvider() instead.\");\n  };\n  alchemyWeb3.setWriteProvider = setWriteProvider;\n  function getNfts(params, callback) {\n    return callAlchemyRestEndpoint({\n      restSender: restSender,\n      callback: callback,\n      params: params,\n      path: \"getNFTs\"\n    });\n  }\n  alchemyWeb3.alchemy = {\n    getTokenAllowance: function (params, callback) {\n      return callAlchemyJsonRpcMethod({\n        jsonRpcSenders: jsonRpcSenders,\n        callback: callback,\n        method: \"alchemy_getTokenAllowance\",\n        params: [params]\n      });\n    },\n    getTokenBalances: function (address, contractAddresses, callback) {\n      return callAlchemyJsonRpcMethod({\n        jsonRpcSenders: jsonRpcSenders,\n        callback: callback,\n        method: \"alchemy_getTokenBalances\",\n        params: [address, contractAddresses || DEFAULT_CONTRACT_ADDRESS],\n        processResponse: processTokenBalanceResponse\n      });\n    },\n    getTokenMetadata: function (address, callback) {\n      return callAlchemyJsonRpcMethod({\n        jsonRpcSenders: jsonRpcSenders,\n        callback: callback,\n        params: [address],\n        method: \"alchemy_getTokenMetadata\"\n      });\n    },\n    getAssetTransfers: function (params, callback) {\n      return callAlchemyJsonRpcMethod({\n        jsonRpcSenders: jsonRpcSenders,\n        callback: callback,\n        params: [__assign(__assign({}, params), {\n          fromBlock: params.fromBlock != null ? formatBlock(params.fromBlock) : undefined,\n          toBlock: params.toBlock != null ? formatBlock(params.toBlock) : undefined,\n          maxCount: params.maxCount != null ? toHex(params.maxCount) : undefined\n        })],\n        method: \"alchemy_getAssetTransfers\"\n      });\n    },\n    getNftMetadata: function (params, callback) {\n      return callAlchemyRestEndpoint({\n        restSender: restSender,\n        callback: callback,\n        params: params,\n        path: \"getNFTMetadata\"\n      });\n    },\n    getNfts: getNfts,\n    getTransactionReceipts: function (params, callback) {\n      return callAlchemyJsonRpcMethod({\n        jsonRpcSenders: jsonRpcSenders,\n        callback: callback,\n        method: \"alchemy_getTransactionReceipts\",\n        params: [params]\n      });\n    }\n  };\n  patchSubscriptions(alchemyWeb3);\n  patchEnableCustomRPC(alchemyWeb3);\n  patchEthMaxPriorityFeePerGasMethod(alchemyWeb3);\n  patchEthPrivateTransactionMethods(alchemyWeb3);\n  return alchemyWeb3;\n}\nfunction fillInConfigDefaults(_a) {\n  var _b = _a === void 0 ? {} : _a,\n    _c = _b.writeProvider,\n    writeProvider = _c === void 0 ? getWindowProvider() : _c,\n    _d = _b.jsonRpcSenderMiddlewares,\n    jsonRpcSenderMiddlewares = _d === void 0 ? [] : _d,\n    _e = _b.maxRetries,\n    maxRetries = _e === void 0 ? DEFAULT_MAX_RETRIES : _e,\n    _f = _b.retryInterval,\n    retryInterval = _f === void 0 ? DEFAULT_RETRY_INTERVAL : _f,\n    _g = _b.retryJitter,\n    retryJitter = _g === void 0 ? DEFAULT_RETRY_JITTER : _g;\n  return {\n    writeProvider: writeProvider,\n    jsonRpcSenderMiddlewares: jsonRpcSenderMiddlewares,\n    maxRetries: maxRetries,\n    retryInterval: retryInterval,\n    retryJitter: retryJitter\n  };\n}\nfunction getWindowProvider() {\n  return typeof window !== \"undefined\" ? window.ethereum : null;\n}\nfunction callAlchemyJsonRpcMethod(_a) {\n  var _this = this;\n  var jsonRpcSenders = _a.jsonRpcSenders,\n    method = _a.method,\n    params = _a.params,\n    _b = _a.callback,\n    callback = _b === void 0 ? noop : _b,\n    _c = _a.processResponse,\n    processResponse = _c === void 0 ? identity : _c;\n  var promise = function () {\n    return __awaiter(_this, void 0, void 0, function () {\n      var result;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, jsonRpcSenders.send(method, params)];\n          case 1:\n            result = _a.sent();\n            return [2 /*return*/, processResponse(result)];\n        }\n      });\n    });\n  }();\n  callWhenDone(promise, callback);\n  return promise;\n}\nfunction callAlchemyRestEndpoint(_a) {\n  var _this = this;\n  var restSender = _a.restSender,\n    path = _a.path,\n    params = _a.params,\n    _b = _a.callback,\n    callback = _b === void 0 ? noop : _b,\n    _c = _a.processResponse,\n    processResponse = _c === void 0 ? identity : _c;\n  var fixedParams = fixArrayQueryParams(params);\n  var promise = function () {\n    return __awaiter(_this, void 0, void 0, function () {\n      var result;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, restSender.sendRestPayload(path, fixedParams)];\n          case 1:\n            result = _a.sent();\n            return [2 /*return*/, processResponse(result)];\n        }\n      });\n    });\n  }();\n  callWhenDone(promise, callback);\n  return promise;\n}\nfunction processTokenBalanceResponse(rawResponse) {\n  // Convert token balance fields from hex-string to decimal-string.\n  var fixedTokenBalances = rawResponse.tokenBalances.map(function (balance) {\n    return balance.tokenBalance != null ? __assign(__assign({}, balance), {\n      tokenBalance: ABIDecoder.decodeParameter(\"uint256\", balance.tokenBalance)\n    }) : balance;\n  });\n  return __assign(__assign({}, rawResponse), {\n    tokenBalances: fixedTokenBalances\n  });\n}\n/**\n * Updates Web3's internal subscription architecture to also handle Alchemy\n * specific subscriptions. This is to handle alternate namings of the existing\n * subscription endpoints, but the officially documented interfaces are\n * specified in the AlchemyEth interface.\n */\nfunction patchSubscriptions(web3) {\n  var eth = web3.eth;\n  var oldSubscribe = eth.subscribe.bind(eth);\n  eth.subscribe = function (type) {\n    var rest = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      rest[_i - 1] = arguments[_i];\n    }\n    if (type === \"alchemy_fullPendingTransactions\" || type === \"alchemy_newFullPendingTransactions\") {\n      console.warn(\"This method is now deprecated. Please use `alchemy_pendingTransactions` instead.\");\n      return suppressNoSubscriptionExistsWarning(function () {\n        return oldSubscribe.apply(void 0, __spreadArray([\"alchemy_newFullPendingTransactions\"], __read(rest)));\n      });\n    }\n    if (type === \"alchemy_filteredNewFullPendingTransactions\" || type === \"alchemy_filteredPendingTransactions\" || type === \"alchemy_filteredFullPendingTransactions\") {\n      console.warn(\"This method is now deprecated. Please use `alchemy_pendingTransactions` instead.\");\n      return suppressNoSubscriptionExistsWarning(function () {\n        return oldSubscribe.apply(void 0, __spreadArray([\"alchemy_filteredNewFullPendingTransactions\"], __read(rest)));\n      });\n    }\n    if (type === \"alchemy_pendingTransactions\") {\n      return suppressNoSubscriptionExistsWarning(function () {\n        return oldSubscribe.apply(void 0, __spreadArray([\"alchemy_pendingTransactions\"], __read(rest)));\n      });\n    }\n    return oldSubscribe.apply(void 0, __spreadArray([type], __read(rest)));\n  };\n}\n/**\n * VERY hacky wrapper to suppress a spurious warning when subscribing to an\n * Alchemy subscription that isn't built into Web3.\n */\nfunction suppressNoSubscriptionExistsWarning(f) {\n  var oldConsoleWarn = console.warn;\n  console.warn = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    if (typeof args[0] === \"string\" && args[0].includes(\" doesn't exist. Subscribing anyway.\")) {\n      return;\n    }\n    return oldConsoleWarn.apply(console, args);\n  };\n  try {\n    return f();\n  } finally {\n    console.warn = oldConsoleWarn;\n  }\n}\n/**\n * Another VERY hacky monkeypatch to make sure that we can take extra parameters to certain alchemy subscriptions\n * I hate doing this, but the other option is to fork web3-core and I think for now this is better\n */\nvar subscription = web3CoreSubscriptions.subscription;\nvar oldSubscriptionPrototypeValidateArgs = subscription.prototype._validateArgs;\nsubscription.prototype._validateArgs = function (args) {\n  if ([\"alchemy_filteredNewFullPendingTransactions\", \"alchemy_filteredPendingTransactions\", \"alchemy_filteredFullPendingTransactions\", \"alchemy_pendingTransactions\"].includes(this.subscriptionMethod)) {\n    // This particular subscription type is allowed to have additional parameters\n  } else {\n    if ([\"alchemy_fullPendingTransactions\", \"alchemy_newFullPendingTransactions\"].includes(this.subscriptionMethod)) {\n      if (this.options.subscription) {\n        this.options.subscription.subscriptionName = this.subscriptionMethod;\n      }\n    }\n    var validator = oldSubscriptionPrototypeValidateArgs.bind(this);\n    validator(args);\n  }\n};\nfunction noop() {\n  // Nothing.\n}\nfunction identity(x) {\n  return x;\n}\n/**\n * Alchemy's APIs receive multivalued params via keys with `[]` at the end.\n * Update any query params whose values are arrays to match this convention.\n */\nfunction fixArrayQueryParams(params) {\n  var result = {};\n  Object.keys(params).forEach(function (key) {\n    var value = params[key];\n    var fixedKey = Array.isArray(value) ? toArrayKey(key) : key;\n    result[fixedKey] = value;\n  });\n  return result;\n}\nfunction toArrayKey(key) {\n  return endsWith(key, \"[]\") ? key : key + \"[]\";\n}\n/**\n * Like `String#endsWith`, for older environments.\n */\nfunction endsWith(s, ending) {\n  var index = s.lastIndexOf(ending);\n  return index >= 0 && index === s.length - ending.length;\n}","map":{"version":3,"names":["Web3","web3CoreSubscriptions","ABIDecoder","toHex","formatBlock","callWhenDone","makeAlchemyContext","patchEnableCustomRPC","patchEthMaxPriorityFeePerGasMethod","patchEthPrivateTransactionMethods","DEFAULT_MAX_RETRIES","DEFAULT_RETRY_INTERVAL","DEFAULT_RETRY_JITTER","DEFAULT_CONTRACT_ADDRESS","createAlchemyWeb3","alchemyUrl","config","fullConfig","fillInConfigDefaults","_a","provider","jsonRpcSenders","restSender","setWriteProvider","alchemyWeb3","setProvider","Error","getNfts","params","callback","callAlchemyRestEndpoint","path","alchemy","getTokenAllowance","callAlchemyJsonRpcMethod","method","getTokenBalances","address","contractAddresses","processResponse","processTokenBalanceResponse","getTokenMetadata","getAssetTransfers","fromBlock","undefined","toBlock","maxCount","getNftMetadata","getTransactionReceipts","patchSubscriptions","_b","_c","writeProvider","getWindowProvider","_d","jsonRpcSenderMiddlewares","_e","maxRetries","_f","retryInterval","_g","retryJitter","window","ethereum","_this","noop","identity","promise","__awaiter","send","result","sent","fixedParams","fixArrayQueryParams","sendRestPayload","rawResponse","fixedTokenBalances","tokenBalances","map","balance","tokenBalance","__assign","decodeParameter","web3","eth","oldSubscribe","subscribe","bind","type","rest","_i","arguments","length","console","warn","suppressNoSubscriptionExistsWarning","apply","__spreadArray","__read","f","oldConsoleWarn","args","includes","subscription","oldSubscriptionPrototypeValidateArgs","prototype","_validateArgs","subscriptionMethod","options","subscriptionName","validator","x","Object","keys","forEach","key","value","fixedKey","Array","isArray","toArrayKey","endsWith","s","ending","index","lastIndexOf"],"sources":["../../src/index.ts"],"sourcesContent":["import Web3 from \"web3\";\nimport { Log, LogsOptions, Transaction } from \"web3-core\";\nimport web3CoreSubscriptions, { Subscription } from \"web3-core-subscriptions\";\nimport { BlockHeader, Eth, Syncing } from \"web3-eth\";\nimport ABIDecoder from \"web3-eth-abi\";\nimport { toHex } from \"web3-utils\";\nimport {\n  AssetTransfersParams,\n  AssetTransfersResponse,\n  GetNftMetadataParams,\n  GetNftMetadataResponse,\n  GetNftsParams,\n  GetNftsParamsWithoutMetadata,\n  GetNftsResponse,\n  GetNftsResponseWithoutMetadata,\n  PrivateTransactionPreferences,\n  TokenAllowanceParams,\n  TokenAllowanceResponse,\n  TokenBalancesResponse,\n  TokenMetadataResponse,\n  TransactionReceiptsParams,\n  TransactionReceiptsResponse,\n} from \"./alchemy-apis/types\";\nimport {\n  AlchemyWeb3Config,\n  FullConfig,\n  PendingTransactionsOptions,\n  PendingTransactionsOptionsHashesOnly,\n  Provider,\n  TransactionsOptions,\n  Web3Callback,\n} from \"./types\";\nimport { formatBlock } from \"./util/hex\";\nimport { JsonRpcSenders } from \"./util/jsonRpc\";\nimport { callWhenDone } from \"./util/promises\";\nimport { makeAlchemyContext } from \"./web3-adapter/alchemyContext\";\nimport { patchEnableCustomRPC } from \"./web3-adapter/customRPC\";\nimport { patchEthMaxPriorityFeePerGasMethod } from \"./web3-adapter/eth_maxPriorityFeePerGas\";\nimport { patchEthPrivateTransactionMethods } from \"./web3-adapter/eth_PrivateTransactions\";\nimport { RestPayloadSender } from \"./web3-adapter/sendRestPayload\";\n\nexport * from \"./alchemy-apis/types\";\n\nconst DEFAULT_MAX_RETRIES = 3;\nconst DEFAULT_RETRY_INTERVAL = 1000;\nconst DEFAULT_RETRY_JITTER = 250;\nconst DEFAULT_CONTRACT_ADDRESS = \"DEFAULT_TOKENS\";\n\nexport interface AlchemyWeb3 extends Web3 {\n  alchemy: AlchemyMethods;\n  eth: AlchemyEth;\n  setWriteProvider(provider: Provider | null | undefined): void;\n}\n\nexport interface AlchemyMethods {\n  getTokenAllowance(\n    params: TokenAllowanceParams,\n    callback?: Web3Callback<TokenAllowanceResponse>,\n  ): Promise<TokenAllowanceResponse>;\n  getTokenBalances(\n    address: string,\n    contractAddresses?: string[],\n    callback?: Web3Callback<TokenBalancesResponse>,\n  ): Promise<TokenBalancesResponse>;\n  getTokenMetadata(\n    address: string,\n    callback?: Web3Callback<TokenMetadataResponse>,\n  ): Promise<TokenMetadataResponse>;\n  getAssetTransfers(\n    params: AssetTransfersParams,\n    callback?: Web3Callback<AssetTransfersResponse>,\n  ): Promise<AssetTransfersResponse>;\n  getNftMetadata(\n    params: GetNftMetadataParams,\n    callback?: Web3Callback<GetNftMetadataResponse>,\n  ): Promise<GetNftMetadataResponse>;\n  getNfts(\n    params: GetNftsParamsWithoutMetadata,\n    callback?: Web3Callback<GetNftsResponseWithoutMetadata>,\n  ): Promise<GetNftsResponseWithoutMetadata>;\n  getNfts(\n    params: GetNftsParams,\n    callback?: Web3Callback<GetNftsResponse>,\n  ): Promise<GetNftsResponse>;\n  getTransactionReceipts(\n    params: TransactionReceiptsParams,\n    callback?: Web3Callback<TransactionReceiptsResponse>,\n  ): Promise<TransactionReceiptsResponse>;\n}\n\n/**\n * Same as Eth, but with `subscribe` allowing more types.\n */\nexport interface AlchemyEth extends Eth {\n  subscribe(\n    type: \"logs\",\n    options?: LogsOptions,\n    callback?: (error: Error, log: Log) => void,\n  ): Subscription<Log>;\n  subscribe(\n    type: \"syncing\",\n    callback?: (error: Error, result: Syncing) => void,\n  ): Subscription<Syncing>;\n  subscribe(\n    type: \"newBlockHeaders\",\n    callback?: (error: Error, blockHeader: BlockHeader) => void,\n  ): Subscription<BlockHeader>;\n  subscribe(\n    type: \"pendingTransactions\",\n    callback?: (error: Error, transactionHash: string) => void,\n  ): Subscription<string>;\n  subscribe(\n    type: \"alchemy_fullPendingTransactions\",\n    callback?: (error: Error, transaction: Transaction) => void,\n  ): Subscription<Transaction>;\n  subscribe(\n    type: \"alchemy_filteredFullPendingTransactions\",\n    options?: TransactionsOptions,\n    callback?: (error: Error, transaction: Transaction) => void,\n  ): Subscription<Transaction>;\n  subscribe(\n    type: \"alchemy_pendingTransactions\",\n    options?: PendingTransactionsOptionsHashesOnly,\n    callback?: (error: Error, transactionHash: string) => void,\n  ): Subscription<string>;\n  subscribe(\n    type: \"alchemy_pendingTransactions\",\n    options?: PendingTransactionsOptions,\n    callback?: (error: Error, transaction: Transaction) => void,\n  ): Subscription<Transaction>;\n  subscribe(\n    type:\n      | \"pendingTransactions\"\n      | \"logs\"\n      | \"syncing\"\n      | \"newBlockHeaders\"\n      | \"alchemy_fullPendingTransactions\"\n      | \"alchemy_filteredFullPendingTransactions\"\n      | \"alchemy_pendingTransactions\",\n    options?: null | LogsOptions | TransactionsOptions,\n    callback?: (\n      error: Error,\n      item: Log | Syncing | BlockHeader | string | Transaction,\n    ) => void,\n  ): Subscription<Log | BlockHeader | Syncing | string | Transaction>;\n  getMaxPriorityFeePerGas(\n    callback?: (error: Error, fee: string) => void,\n  ): Promise<string>;\n  sendPrivateTransaction(\n    tx: string,\n    maxBlockNumber?: string,\n    preferences?: PrivateTransactionPreferences,\n    callback?: (error: Error, hash: string) => void,\n  ): Promise<string>;\n  cancelPrivateTransaction(\n    txHash: string,\n    callback?: (error: Error, result: boolean) => void,\n  ): Promise<boolean>;\n}\n\ninterface EthereumWindow extends Window {\n  ethereum?: any;\n}\n\ndeclare const window: EthereumWindow;\n\nexport function createAlchemyWeb3(\n  alchemyUrl: string,\n  config?: AlchemyWeb3Config,\n): AlchemyWeb3 {\n  const fullConfig = fillInConfigDefaults(config);\n  const { provider, jsonRpcSenders, restSender, setWriteProvider } =\n    makeAlchemyContext(alchemyUrl, fullConfig);\n  const alchemyWeb3 = new Web3(provider) as AlchemyWeb3;\n  alchemyWeb3.setProvider = () => {\n    throw new Error(\n      \"setProvider is not supported in Alchemy Web3. To change the provider used for writes, use setWriteProvider() instead.\",\n    );\n  };\n  alchemyWeb3.setWriteProvider = setWriteProvider;\n\n  // Define function separately in order to allow for overloads.\n  function getNfts(\n    params: GetNftsParamsWithoutMetadata,\n    callback?: Web3Callback<GetNftsResponseWithoutMetadata>,\n  ): Promise<GetNftsResponseWithoutMetadata>;\n  function getNfts(\n    params: GetNftsParams,\n    callback?: Web3Callback<GetNftsResponse>,\n  ): Promise<GetNftsResponse>;\n  function getNfts(\n    params: GetNftsParams | GetNftsParamsWithoutMetadata,\n    callback?:\n      | Web3Callback<GetNftsResponseWithoutMetadata>\n      | Web3Callback<GetNftsResponse>,\n  ): Promise<GetNftsResponse | GetNftsResponseWithoutMetadata> {\n    return callAlchemyRestEndpoint({\n      restSender,\n      callback,\n      params,\n      path: \"getNFTs\",\n    });\n  }\n\n  alchemyWeb3.alchemy = {\n    getTokenAllowance: (params: TokenAllowanceParams, callback) =>\n      callAlchemyJsonRpcMethod({\n        jsonRpcSenders,\n        callback,\n        method: \"alchemy_getTokenAllowance\",\n        params: [params],\n      }),\n    getTokenBalances: (address, contractAddresses, callback) =>\n      callAlchemyJsonRpcMethod({\n        jsonRpcSenders,\n        callback,\n        method: \"alchemy_getTokenBalances\",\n        params: [address, contractAddresses || DEFAULT_CONTRACT_ADDRESS],\n        processResponse: processTokenBalanceResponse,\n      }),\n    getTokenMetadata: (address, callback) =>\n      callAlchemyJsonRpcMethod({\n        jsonRpcSenders,\n        callback,\n        params: [address],\n        method: \"alchemy_getTokenMetadata\",\n      }),\n    getAssetTransfers: (params: AssetTransfersParams, callback) =>\n      callAlchemyJsonRpcMethod({\n        jsonRpcSenders,\n        callback,\n        params: [\n          {\n            ...params,\n            fromBlock:\n              params.fromBlock != null\n                ? formatBlock(params.fromBlock)\n                : undefined,\n            toBlock:\n              params.toBlock != null ? formatBlock(params.toBlock) : undefined,\n            maxCount:\n              params.maxCount != null ? toHex(params.maxCount) : undefined,\n          },\n        ],\n        method: \"alchemy_getAssetTransfers\",\n      }),\n    getNftMetadata: (params: GetNftMetadataParams, callback) =>\n      callAlchemyRestEndpoint({\n        restSender,\n        callback,\n        params,\n        path: \"getNFTMetadata\",\n      }),\n    getNfts,\n    getTransactionReceipts: (params: TransactionReceiptsParams, callback) =>\n      callAlchemyJsonRpcMethod({\n        jsonRpcSenders,\n        callback,\n        method: \"alchemy_getTransactionReceipts\",\n        params: [params],\n      }),\n  };\n  patchSubscriptions(alchemyWeb3);\n  patchEnableCustomRPC(alchemyWeb3);\n  patchEthMaxPriorityFeePerGasMethod(alchemyWeb3);\n  patchEthPrivateTransactionMethods(alchemyWeb3);\n  return alchemyWeb3;\n}\n\nfunction fillInConfigDefaults({\n  writeProvider = getWindowProvider(),\n  jsonRpcSenderMiddlewares = [],\n  maxRetries = DEFAULT_MAX_RETRIES,\n  retryInterval = DEFAULT_RETRY_INTERVAL,\n  retryJitter = DEFAULT_RETRY_JITTER,\n}: AlchemyWeb3Config = {}): FullConfig {\n  return {\n    writeProvider,\n    jsonRpcSenderMiddlewares,\n    maxRetries,\n    retryInterval,\n    retryJitter,\n  };\n}\n\nfunction getWindowProvider(): Provider | null {\n  return typeof window !== \"undefined\" ? window.ethereum : null;\n}\n\ninterface CallAlchemyJsonRpcMethodParams<T> {\n  jsonRpcSenders: JsonRpcSenders;\n  method: string;\n  params: any[];\n  callback?: Web3Callback<T>;\n  processResponse?(response: any): T;\n}\n\ninterface CallAlchemyRestEndpoint<T> {\n  restSender: RestPayloadSender;\n  path: string;\n  params: Record<string, any>;\n  callback?: Web3Callback<T>;\n  processResponse?(response: any): T;\n}\n\nfunction callAlchemyJsonRpcMethod<T>({\n  jsonRpcSenders,\n  method,\n  params,\n  callback = noop,\n  processResponse = identity,\n}: CallAlchemyJsonRpcMethodParams<T>): Promise<T> {\n  const promise = (async () => {\n    const result = await jsonRpcSenders.send(method, params);\n    return processResponse(result);\n  })();\n  callWhenDone(promise, callback);\n  return promise;\n}\n\nfunction callAlchemyRestEndpoint<T>({\n  restSender,\n  path,\n  params,\n  callback = noop,\n  processResponse = identity,\n}: CallAlchemyRestEndpoint<T>): Promise<T> {\n  const fixedParams = fixArrayQueryParams(params);\n  const promise = (async () => {\n    const result = await restSender.sendRestPayload(path, fixedParams);\n    return processResponse(result);\n  })();\n  callWhenDone(promise, callback);\n  return promise;\n}\n\nfunction processTokenBalanceResponse(\n  rawResponse: TokenBalancesResponse,\n): TokenBalancesResponse {\n  // Convert token balance fields from hex-string to decimal-string.\n  const fixedTokenBalances = rawResponse.tokenBalances.map((balance) =>\n    balance.tokenBalance != null\n      ? {\n          ...balance,\n          tokenBalance: ABIDecoder.decodeParameter(\n            \"uint256\",\n            balance.tokenBalance,\n          ),\n        }\n      : balance,\n  );\n  return { ...rawResponse, tokenBalances: fixedTokenBalances };\n}\n\n/**\n * Updates Web3's internal subscription architecture to also handle Alchemy\n * specific subscriptions. This is to handle alternate namings of the existing\n * subscription endpoints, but the officially documented interfaces are\n * specified in the AlchemyEth interface.\n */\nfunction patchSubscriptions(web3: Web3): void {\n  const { eth } = web3;\n  const oldSubscribe = eth.subscribe.bind(eth);\n  eth.subscribe = ((type: string, ...rest: any[]) => {\n    if (\n      type === \"alchemy_fullPendingTransactions\" ||\n      type === \"alchemy_newFullPendingTransactions\"\n    ) {\n      console.warn(\n        \"This method is now deprecated. Please use `alchemy_pendingTransactions` instead.\",\n      );\n      return suppressNoSubscriptionExistsWarning(() =>\n        oldSubscribe(\"alchemy_newFullPendingTransactions\" as any, ...rest),\n      );\n    }\n    if (\n      type === \"alchemy_filteredNewFullPendingTransactions\" ||\n      type === \"alchemy_filteredPendingTransactions\" ||\n      type === \"alchemy_filteredFullPendingTransactions\"\n    ) {\n      console.warn(\n        \"This method is now deprecated. Please use `alchemy_pendingTransactions` instead.\",\n      );\n      return suppressNoSubscriptionExistsWarning(() =>\n        oldSubscribe(\n          \"alchemy_filteredNewFullPendingTransactions\" as any,\n          ...rest,\n        ),\n      );\n    }\n\n    if (type === \"alchemy_pendingTransactions\") {\n      return suppressNoSubscriptionExistsWarning(() =>\n        oldSubscribe(\"alchemy_pendingTransactions\" as any, ...rest),\n      );\n    }\n    return oldSubscribe(type as any, ...rest);\n  }) as any;\n}\n\n/**\n * VERY hacky wrapper to suppress a spurious warning when subscribing to an\n * Alchemy subscription that isn't built into Web3.\n */\nfunction suppressNoSubscriptionExistsWarning<T>(f: () => T): T {\n  const oldConsoleWarn = console.warn;\n  console.warn = (...args: unknown[]) => {\n    if (\n      typeof args[0] === \"string\" &&\n      args[0].includes(\" doesn't exist. Subscribing anyway.\")\n    ) {\n      return;\n    }\n    return oldConsoleWarn.apply(console, args);\n  };\n  try {\n    return f();\n  } finally {\n    console.warn = oldConsoleWarn;\n  }\n}\n\n/**\n * Another VERY hacky monkeypatch to make sure that we can take extra parameters to certain alchemy subscriptions\n * I hate doing this, but the other option is to fork web3-core and I think for now this is better\n */\nconst { subscription } = web3CoreSubscriptions as any;\nconst oldSubscriptionPrototypeValidateArgs =\n  subscription.prototype._validateArgs;\nsubscription.prototype._validateArgs = function (args: any) {\n  if (\n    [\n      \"alchemy_filteredNewFullPendingTransactions\",\n      \"alchemy_filteredPendingTransactions\",\n      \"alchemy_filteredFullPendingTransactions\",\n      \"alchemy_pendingTransactions\",\n    ].includes(this.subscriptionMethod)\n  ) {\n    // This particular subscription type is allowed to have additional parameters\n  } else {\n    if (\n      [\n        \"alchemy_fullPendingTransactions\",\n        \"alchemy_newFullPendingTransactions\",\n      ].includes(this.subscriptionMethod)\n    ) {\n      if (this.options.subscription) {\n        this.options.subscription.subscriptionName = this.subscriptionMethod;\n      }\n    }\n\n    const validator = oldSubscriptionPrototypeValidateArgs.bind(this);\n    validator(args);\n  }\n};\n\nfunction noop(): void {\n  // Nothing.\n}\n\nfunction identity<T>(x: T): T {\n  return x;\n}\n\n/**\n * Alchemy's APIs receive multivalued params via keys with `[]` at the end.\n * Update any query params whose values are arrays to match this convention.\n */\nfunction fixArrayQueryParams(params: Record<string, any>): Record<string, any> {\n  const result: Record<string, any> = {};\n  Object.keys(params).forEach((key) => {\n    const value = params[key];\n    const fixedKey = Array.isArray(value) ? toArrayKey(key) : key;\n    result[fixedKey] = value;\n  });\n  return result;\n}\n\nfunction toArrayKey(key: string): string {\n  return endsWith(key, \"[]\") ? key : `${key}[]`;\n}\n\n/**\n * Like `String#endsWith`, for older environments.\n */\nfunction endsWith(s: string, ending: string): boolean {\n  const index = s.lastIndexOf(ending);\n  return index >= 0 && index === s.length - ending.length;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}