{"ast":null,"code":"/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * @file index.js\n * @author Marek Kotewicz <marek@parity.io>\n * @author Fabian Vogelsteller <fabian@frozeman.de>\n * @date 2018\n */\nvar Buffer = require('buffer').Buffer;\nvar utils = require('web3-utils');\nvar EthersAbiCoder = require('@ethersproject/abi').AbiCoder;\nvar ParamType = require('@ethersproject/abi').ParamType;\nvar ethersAbiCoder = new EthersAbiCoder(function (type, value) {\n  if (type.match(/^u?int/) && !Array.isArray(value) && (!(!!value && typeof value === 'object') || value.constructor.name !== 'BN')) {\n    return value.toString();\n  }\n  return value;\n});\n// result method\nfunction Result() {}\n/**\n * ABICoder prototype should be used to encode/decode solidity params of any type\n */\nvar ABICoder = function () {};\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeFunctionSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\nABICoder.prototype.encodeFunctionSignature = function (functionName) {\n  if (typeof functionName === 'function' || typeof functionName === 'object' && functionName) {\n    functionName = utils._jsonInterfaceMethodToString(functionName);\n  }\n  return utils.sha3(functionName).slice(0, 10);\n};\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeEventSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\nABICoder.prototype.encodeEventSignature = function (functionName) {\n  if (typeof functionName === 'function' || typeof functionName === 'object' && functionName) {\n    functionName = utils._jsonInterfaceMethodToString(functionName);\n  }\n  return utils.sha3(functionName);\n};\n/**\n * Should be used to encode plain param\n *\n * @method encodeParameter\n *\n * @param {String|Object} type\n * @param {any} param\n *\n * @return {String} encoded plain param\n */\nABICoder.prototype.encodeParameter = function (type, param) {\n  return this.encodeParameters([type], [param]);\n};\n/**\n * Should be used to encode list of params\n *\n * @method encodeParameters\n *\n * @param {Array<String|Object>} types\n * @param {Array<any>} params\n *\n * @return {String} encoded list of params\n */\nABICoder.prototype.encodeParameters = function (types, params) {\n  var self = this;\n  types = self.mapTypes(types);\n  params = params.map(function (param, index) {\n    let type = types[index];\n    if (typeof type === 'object' && type.type) {\n      // We may get a named type of shape {name, type}\n      type = type.type;\n    }\n    param = self.formatParam(type, param);\n    // Format params for tuples\n    if (typeof type === 'string' && type.includes('tuple')) {\n      const coder = ethersAbiCoder._getCoder(ParamType.from(type));\n      const modifyParams = (coder, param) => {\n        if (coder.name === 'array') {\n          if (!coder.type.match(/\\[(\\d+)\\]/)) {\n            return param.map(p => modifyParams(ethersAbiCoder._getCoder(ParamType.from(coder.type.replace('[]', ''))), p));\n          }\n          const arrayLength = parseInt(coder.type.match(/\\[(\\d+)\\]/)[1]);\n          if (param.length !== arrayLength) {\n            throw new Error('Array length does not matches with the given input');\n          }\n          return param.map(p => modifyParams(ethersAbiCoder._getCoder(ParamType.from(coder.type.replace(/\\[\\d+\\]/, ''))), p));\n        }\n        coder.coders.forEach((c, i) => {\n          if (c.name === 'tuple') {\n            modifyParams(c, param[i]);\n          } else {\n            param[i] = self.formatParam(c.name, param[i]);\n          }\n        });\n      };\n      modifyParams(coder, param);\n    }\n    return param;\n  });\n  return ethersAbiCoder.encode(types, params);\n};\n/**\n * Map types if simplified format is used\n *\n * @method mapTypes\n * @param {Array} types\n * @return {Array}\n */\nABICoder.prototype.mapTypes = function (types) {\n  var self = this;\n  var mappedTypes = [];\n  types.forEach(function (type) {\n    // Remap `function` type params to bytes24 since Ethers does not\n    // recognize former type. Solidity docs say `Function` is a bytes24\n    // encoding the contract address followed by the function selector hash.\n    if (typeof type === 'object' && type.type === 'function') {\n      type = Object.assign({}, type, {\n        type: \"bytes24\"\n      });\n    }\n    if (self.isSimplifiedStructFormat(type)) {\n      var structName = Object.keys(type)[0];\n      mappedTypes.push(Object.assign(self.mapStructNameAndType(structName), {\n        components: self.mapStructToCoderFormat(type[structName])\n      }));\n      return;\n    }\n    mappedTypes.push(type);\n  });\n  return mappedTypes;\n};\n/**\n * Check if type is simplified struct format\n *\n * @method isSimplifiedStructFormat\n * @param {string | Object} type\n * @returns {boolean}\n */\nABICoder.prototype.isSimplifiedStructFormat = function (type) {\n  return typeof type === 'object' && typeof type.components === 'undefined' && typeof type.name === 'undefined';\n};\n/**\n * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\n *\n * @method mapStructNameAndType\n * @param {string} structName\n * @return {{type: string, name: *}}\n */\nABICoder.prototype.mapStructNameAndType = function (structName) {\n  var type = 'tuple';\n  if (structName.indexOf('[]') > -1) {\n    type = 'tuple[]';\n    structName = structName.slice(0, -2);\n  }\n  return {\n    type: type,\n    name: structName\n  };\n};\n/**\n * Maps the simplified format in to the expected format of the ABICoder\n *\n * @method mapStructToCoderFormat\n * @param {Object} struct\n * @return {Array}\n */\nABICoder.prototype.mapStructToCoderFormat = function (struct) {\n  var self = this;\n  var components = [];\n  Object.keys(struct).forEach(function (key) {\n    if (typeof struct[key] === 'object') {\n      components.push(Object.assign(self.mapStructNameAndType(key), {\n        components: self.mapStructToCoderFormat(struct[key])\n      }));\n      return;\n    }\n    components.push({\n      name: key,\n      type: struct[key]\n    });\n  });\n  return components;\n};\n/**\n * Handle some formatting of params for backwards compatability with Ethers V4\n *\n * @method formatParam\n * @param {String} - type\n * @param {any} - param\n * @return {any} - The formatted param\n */\nABICoder.prototype.formatParam = function (type, param) {\n  const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\n  const paramTypeBytesArray = new RegExp(/^bytes([0-9]*)\\[\\]$/);\n  const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n  const paramTypeNumberArray = new RegExp(/^(u?int)([0-9]*)\\[\\]$/);\n  // Format BN to string\n  if (utils.isBN(param) || utils.isBigNumber(param)) {\n    return param.toString(10);\n  }\n  if (type.match(paramTypeBytesArray) || type.match(paramTypeNumberArray)) {\n    return param.map(p => this.formatParam(type.replace('[]', ''), p));\n  }\n  // Format correct width for u?int[0-9]*\n  let match = type.match(paramTypeNumber);\n  if (match) {\n    let size = parseInt(match[2] || \"256\");\n    if (size / 8 < param.length) {\n      // pad to correct bit width\n      param = utils.leftPad(param, size);\n    }\n  }\n  // Format correct length for bytes[0-9]+\n  match = type.match(paramTypeBytes);\n  if (match) {\n    if (Buffer.isBuffer(param)) {\n      param = utils.toHex(param);\n    }\n    // format to correct length\n    let size = parseInt(match[1]);\n    if (size) {\n      let maxSize = size * 2;\n      if (param.substring(0, 2) === '0x') {\n        maxSize += 2;\n      }\n      if (param.length < maxSize) {\n        // pad to correct length\n        param = utils.rightPad(param, size * 2);\n      }\n    }\n    // format odd-length bytes to even-length\n    if (param.length % 2 === 1) {\n      param = '0x0' + param.substring(2);\n    }\n  }\n  return param;\n};\n/**\n * Encodes a function call from its json interface and parameters.\n *\n * @method encodeFunctionCall\n * @param {Array} jsonInterface\n * @param {Array} params\n * @return {String} The encoded ABI for this function call\n */\nABICoder.prototype.encodeFunctionCall = function (jsonInterface, params) {\n  return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface.inputs, params).replace('0x', '');\n};\n/**\n * Should be used to decode bytes to plain param\n *\n * @method decodeParameter\n * @param {String} type\n * @param {String} bytes\n * @return {Object} plain param\n */\nABICoder.prototype.decodeParameter = function (type, bytes) {\n  return this.decodeParameters([type], bytes)[0];\n};\n/**\n * Should be used to decode list of params\n *\n * @method decodeParameter\n * @param {Array} outputs\n * @param {String} bytes\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeParameters = function (outputs, bytes) {\n  return this.decodeParametersWith(outputs, bytes, false);\n};\n/**\n * Should be used to decode list of params\n *\n * @method decodeParameter\n * @param {Array} outputs\n * @param {String} bytes\n * @param {Boolean} loose\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeParametersWith = function (outputs, bytes, loose) {\n  if (outputs.length > 0 && (!bytes || bytes === '0x' || bytes === '0X')) {\n    throw new Error('Returned values aren\\'t valid, did it run Out of Gas? ' + 'You might also see this error if you are not using the ' + 'correct ABI for the contract you are retrieving data from, ' + 'requesting data from a block number that does not exist, ' + 'or querying a node which is not fully synced.');\n  }\n  var res = ethersAbiCoder.decode(this.mapTypes(outputs), '0x' + bytes.replace(/0x/i, ''), loose);\n  var returnValue = new Result();\n  returnValue.__length__ = 0;\n  outputs.forEach(function (output, i) {\n    var decodedValue = res[returnValue.__length__];\n    const isStringObject = typeof output === 'object' && output.type && output.type === 'string';\n    const isStringType = typeof output === 'string' && output === 'string';\n    // only convert `0x` to null if it's not string value\n    decodedValue = decodedValue === '0x' && !isStringObject && !isStringType ? null : decodedValue;\n    returnValue[i] = decodedValue;\n    if ((typeof output === 'function' || !!output && typeof output === 'object') && output.name) {\n      returnValue[output.name] = decodedValue;\n    }\n    returnValue.__length__++;\n  });\n  return returnValue;\n};\n/**\n * Decodes events non- and indexed parameters.\n *\n * @method decodeLog\n * @param {Object} inputs\n * @param {String} data\n * @param {Array} topics\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeLog = function (inputs, data, topics) {\n  var _this = this;\n  topics = Array.isArray(topics) ? topics : [topics];\n  data = data || '';\n  var notIndexedInputs = [];\n  var indexedParams = [];\n  var topicCount = 0;\n  // TODO check for anonymous logs?\n  inputs.forEach(function (input, i) {\n    if (input.indexed) {\n      indexedParams[i] = ['bool', 'int', 'uint', 'address', 'fixed', 'ufixed'].find(function (staticType) {\n        return input.type.indexOf(staticType) !== -1;\n      }) ? _this.decodeParameter(input.type, topics[topicCount]) : topics[topicCount];\n      topicCount++;\n    } else {\n      notIndexedInputs[i] = input;\n    }\n  });\n  var nonIndexedData = data;\n  var notIndexedParams = nonIndexedData ? this.decodeParametersWith(notIndexedInputs, nonIndexedData, true) : [];\n  var returnValue = new Result();\n  returnValue.__length__ = 0;\n  inputs.forEach(function (res, i) {\n    returnValue[i] = res.type === 'string' ? '' : null;\n    if (typeof notIndexedParams[i] !== 'undefined') {\n      returnValue[i] = notIndexedParams[i];\n    }\n    if (typeof indexedParams[i] !== 'undefined') {\n      returnValue[i] = indexedParams[i];\n    }\n    if (res.name) {\n      returnValue[res.name] = returnValue[i];\n    }\n    returnValue.__length__++;\n  });\n  return returnValue;\n};\nvar coder = new ABICoder();\nmodule.exports = coder;","map":{"version":3,"names":["Buffer","require","utils","EthersAbiCoder","AbiCoder","ParamType","ethersAbiCoder","type","value","match","Array","isArray","constructor","name","toString","Result","ABICoder","prototype","encodeFunctionSignature","functionName","_jsonInterfaceMethodToString","sha3","slice","encodeEventSignature","encodeParameter","param","encodeParameters","types","params","self","mapTypes","map","index","formatParam","includes","coder","_getCoder","from","modifyParams","p","replace","arrayLength","parseInt","length","Error","coders","forEach","c","i","encode","mappedTypes","Object","assign","isSimplifiedStructFormat","structName","keys","push","mapStructNameAndType","components","mapStructToCoderFormat","indexOf","struct","key","paramTypeBytes","RegExp","paramTypeBytesArray","paramTypeNumber","paramTypeNumberArray","isBN","isBigNumber","size","leftPad","isBuffer","toHex","maxSize","substring","rightPad","encodeFunctionCall","jsonInterface","inputs","decodeParameter","bytes","decodeParameters","outputs","decodeParametersWith","loose","res","decode","returnValue","__length__","output","decodedValue","isStringObject","isStringType","decodeLog","data","topics","_this","notIndexedInputs","indexedParams","topicCount","input","indexed","find","staticType","nonIndexedData","notIndexedParams","module","exports"],"sources":["C:/Users/jack/git/hackathon/starter-files/node_modules/web3-eth-abi/lib/index.js"],"sourcesContent":["/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * @file index.js\n * @author Marek Kotewicz <marek@parity.io>\n * @author Fabian Vogelsteller <fabian@frozeman.de>\n * @date 2018\n */\nvar Buffer = require('buffer').Buffer;\nvar utils = require('web3-utils');\nvar EthersAbiCoder = require('@ethersproject/abi').AbiCoder;\nvar ParamType = require('@ethersproject/abi').ParamType;\nvar ethersAbiCoder = new EthersAbiCoder(function (type, value) {\n    if (type.match(/^u?int/) && !Array.isArray(value) && (!(!!value && typeof value === 'object') || value.constructor.name !== 'BN')) {\n        return value.toString();\n    }\n    return value;\n});\n// result method\nfunction Result() {\n}\n/**\n * ABICoder prototype should be used to encode/decode solidity params of any type\n */\nvar ABICoder = function () {\n};\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeFunctionSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\nABICoder.prototype.encodeFunctionSignature = function (functionName) {\n    if (typeof functionName === 'function' || typeof functionName === 'object' && functionName) {\n        functionName = utils._jsonInterfaceMethodToString(functionName);\n    }\n    return utils.sha3(functionName).slice(0, 10);\n};\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeEventSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\nABICoder.prototype.encodeEventSignature = function (functionName) {\n    if (typeof functionName === 'function' || typeof functionName === 'object' && functionName) {\n        functionName = utils._jsonInterfaceMethodToString(functionName);\n    }\n    return utils.sha3(functionName);\n};\n/**\n * Should be used to encode plain param\n *\n * @method encodeParameter\n *\n * @param {String|Object} type\n * @param {any} param\n *\n * @return {String} encoded plain param\n */\nABICoder.prototype.encodeParameter = function (type, param) {\n    return this.encodeParameters([type], [param]);\n};\n/**\n * Should be used to encode list of params\n *\n * @method encodeParameters\n *\n * @param {Array<String|Object>} types\n * @param {Array<any>} params\n *\n * @return {String} encoded list of params\n */\nABICoder.prototype.encodeParameters = function (types, params) {\n    var self = this;\n    types = self.mapTypes(types);\n    params = params.map(function (param, index) {\n        let type = types[index];\n        if (typeof type === 'object' && type.type) {\n            // We may get a named type of shape {name, type}\n            type = type.type;\n        }\n        param = self.formatParam(type, param);\n        // Format params for tuples\n        if (typeof type === 'string' && type.includes('tuple')) {\n            const coder = ethersAbiCoder._getCoder(ParamType.from(type));\n            const modifyParams = (coder, param) => {\n                if (coder.name === 'array') {\n                    if (!coder.type.match(/\\[(\\d+)\\]/)) {\n                        return param.map(p => modifyParams(ethersAbiCoder._getCoder(ParamType.from(coder.type.replace('[]', ''))), p));\n                    }\n                    const arrayLength = parseInt(coder.type.match(/\\[(\\d+)\\]/)[1]);\n                    if (param.length !== arrayLength) {\n                        throw new Error('Array length does not matches with the given input');\n                    }\n                    return param.map(p => modifyParams(ethersAbiCoder._getCoder(ParamType.from(coder.type.replace(/\\[\\d+\\]/, ''))), p));\n                }\n                coder.coders.forEach((c, i) => {\n                    if (c.name === 'tuple') {\n                        modifyParams(c, param[i]);\n                    }\n                    else {\n                        param[i] = self.formatParam(c.name, param[i]);\n                    }\n                });\n            };\n            modifyParams(coder, param);\n        }\n        return param;\n    });\n    return ethersAbiCoder.encode(types, params);\n};\n/**\n * Map types if simplified format is used\n *\n * @method mapTypes\n * @param {Array} types\n * @return {Array}\n */\nABICoder.prototype.mapTypes = function (types) {\n    var self = this;\n    var mappedTypes = [];\n    types.forEach(function (type) {\n        // Remap `function` type params to bytes24 since Ethers does not\n        // recognize former type. Solidity docs say `Function` is a bytes24\n        // encoding the contract address followed by the function selector hash.\n        if (typeof type === 'object' && type.type === 'function') {\n            type = Object.assign({}, type, { type: \"bytes24\" });\n        }\n        if (self.isSimplifiedStructFormat(type)) {\n            var structName = Object.keys(type)[0];\n            mappedTypes.push(Object.assign(self.mapStructNameAndType(structName), {\n                components: self.mapStructToCoderFormat(type[structName])\n            }));\n            return;\n        }\n        mappedTypes.push(type);\n    });\n    return mappedTypes;\n};\n/**\n * Check if type is simplified struct format\n *\n * @method isSimplifiedStructFormat\n * @param {string | Object} type\n * @returns {boolean}\n */\nABICoder.prototype.isSimplifiedStructFormat = function (type) {\n    return typeof type === 'object' && typeof type.components === 'undefined' && typeof type.name === 'undefined';\n};\n/**\n * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\n *\n * @method mapStructNameAndType\n * @param {string} structName\n * @return {{type: string, name: *}}\n */\nABICoder.prototype.mapStructNameAndType = function (structName) {\n    var type = 'tuple';\n    if (structName.indexOf('[]') > -1) {\n        type = 'tuple[]';\n        structName = structName.slice(0, -2);\n    }\n    return { type: type, name: structName };\n};\n/**\n * Maps the simplified format in to the expected format of the ABICoder\n *\n * @method mapStructToCoderFormat\n * @param {Object} struct\n * @return {Array}\n */\nABICoder.prototype.mapStructToCoderFormat = function (struct) {\n    var self = this;\n    var components = [];\n    Object.keys(struct).forEach(function (key) {\n        if (typeof struct[key] === 'object') {\n            components.push(Object.assign(self.mapStructNameAndType(key), {\n                components: self.mapStructToCoderFormat(struct[key])\n            }));\n            return;\n        }\n        components.push({\n            name: key,\n            type: struct[key]\n        });\n    });\n    return components;\n};\n/**\n * Handle some formatting of params for backwards compatability with Ethers V4\n *\n * @method formatParam\n * @param {String} - type\n * @param {any} - param\n * @return {any} - The formatted param\n */\nABICoder.prototype.formatParam = function (type, param) {\n    const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\n    const paramTypeBytesArray = new RegExp(/^bytes([0-9]*)\\[\\]$/);\n    const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n    const paramTypeNumberArray = new RegExp(/^(u?int)([0-9]*)\\[\\]$/);\n    // Format BN to string\n    if (utils.isBN(param) || utils.isBigNumber(param)) {\n        return param.toString(10);\n    }\n    if (type.match(paramTypeBytesArray) || type.match(paramTypeNumberArray)) {\n        return param.map(p => this.formatParam(type.replace('[]', ''), p));\n    }\n    // Format correct width for u?int[0-9]*\n    let match = type.match(paramTypeNumber);\n    if (match) {\n        let size = parseInt(match[2] || \"256\");\n        if (size / 8 < param.length) {\n            // pad to correct bit width\n            param = utils.leftPad(param, size);\n        }\n    }\n    // Format correct length for bytes[0-9]+\n    match = type.match(paramTypeBytes);\n    if (match) {\n        if (Buffer.isBuffer(param)) {\n            param = utils.toHex(param);\n        }\n        // format to correct length\n        let size = parseInt(match[1]);\n        if (size) {\n            let maxSize = size * 2;\n            if (param.substring(0, 2) === '0x') {\n                maxSize += 2;\n            }\n            if (param.length < maxSize) {\n                // pad to correct length\n                param = utils.rightPad(param, size * 2);\n            }\n        }\n        // format odd-length bytes to even-length\n        if (param.length % 2 === 1) {\n            param = '0x0' + param.substring(2);\n        }\n    }\n    return param;\n};\n/**\n * Encodes a function call from its json interface and parameters.\n *\n * @method encodeFunctionCall\n * @param {Array} jsonInterface\n * @param {Array} params\n * @return {String} The encoded ABI for this function call\n */\nABICoder.prototype.encodeFunctionCall = function (jsonInterface, params) {\n    return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface.inputs, params).replace('0x', '');\n};\n/**\n * Should be used to decode bytes to plain param\n *\n * @method decodeParameter\n * @param {String} type\n * @param {String} bytes\n * @return {Object} plain param\n */\nABICoder.prototype.decodeParameter = function (type, bytes) {\n    return this.decodeParameters([type], bytes)[0];\n};\n/**\n * Should be used to decode list of params\n *\n * @method decodeParameter\n * @param {Array} outputs\n * @param {String} bytes\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeParameters = function (outputs, bytes) {\n    return this.decodeParametersWith(outputs, bytes, false);\n};\n/**\n * Should be used to decode list of params\n *\n * @method decodeParameter\n * @param {Array} outputs\n * @param {String} bytes\n * @param {Boolean} loose\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeParametersWith = function (outputs, bytes, loose) {\n    if (outputs.length > 0 && (!bytes || bytes === '0x' || bytes === '0X')) {\n        throw new Error('Returned values aren\\'t valid, did it run Out of Gas? ' +\n            'You might also see this error if you are not using the ' +\n            'correct ABI for the contract you are retrieving data from, ' +\n            'requesting data from a block number that does not exist, ' +\n            'or querying a node which is not fully synced.');\n    }\n    var res = ethersAbiCoder.decode(this.mapTypes(outputs), '0x' + bytes.replace(/0x/i, ''), loose);\n    var returnValue = new Result();\n    returnValue.__length__ = 0;\n    outputs.forEach(function (output, i) {\n        var decodedValue = res[returnValue.__length__];\n        const isStringObject = typeof output === 'object' && output.type && output.type === 'string';\n        const isStringType = typeof output === 'string' && output === 'string';\n        // only convert `0x` to null if it's not string value\n        decodedValue = (decodedValue === '0x' && !isStringObject && !isStringType) ? null : decodedValue;\n        returnValue[i] = decodedValue;\n        if ((typeof output === 'function' || !!output && typeof output === 'object') && output.name) {\n            returnValue[output.name] = decodedValue;\n        }\n        returnValue.__length__++;\n    });\n    return returnValue;\n};\n/**\n * Decodes events non- and indexed parameters.\n *\n * @method decodeLog\n * @param {Object} inputs\n * @param {String} data\n * @param {Array} topics\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeLog = function (inputs, data, topics) {\n    var _this = this;\n    topics = Array.isArray(topics) ? topics : [topics];\n    data = data || '';\n    var notIndexedInputs = [];\n    var indexedParams = [];\n    var topicCount = 0;\n    // TODO check for anonymous logs?\n    inputs.forEach(function (input, i) {\n        if (input.indexed) {\n            indexedParams[i] = (['bool', 'int', 'uint', 'address', 'fixed', 'ufixed'].find(function (staticType) {\n                return input.type.indexOf(staticType) !== -1;\n            })) ? _this.decodeParameter(input.type, topics[topicCount]) : topics[topicCount];\n            topicCount++;\n        }\n        else {\n            notIndexedInputs[i] = input;\n        }\n    });\n    var nonIndexedData = data;\n    var notIndexedParams = (nonIndexedData) ? this.decodeParametersWith(notIndexedInputs, nonIndexedData, true) : [];\n    var returnValue = new Result();\n    returnValue.__length__ = 0;\n    inputs.forEach(function (res, i) {\n        returnValue[i] = (res.type === 'string') ? '' : null;\n        if (typeof notIndexedParams[i] !== 'undefined') {\n            returnValue[i] = notIndexedParams[i];\n        }\n        if (typeof indexedParams[i] !== 'undefined') {\n            returnValue[i] = indexedParams[i];\n        }\n        if (res.name) {\n            returnValue[res.name] = returnValue[i];\n        }\n        returnValue.__length__++;\n    });\n    return returnValue;\n};\nvar coder = new ABICoder();\nmodule.exports = coder;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}