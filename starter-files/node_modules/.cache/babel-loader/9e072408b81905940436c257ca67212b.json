{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;\nvar assert_1 = __importDefault(require(\"assert\"));\nvar externals_1 = require(\"./externals\");\nvar secp256k1_1 = require(\"ethereum-cryptography/secp256k1\");\nvar internal_1 = require(\"./internal\");\nvar constants_1 = require(\"./constants\");\nvar bytes_1 = require(\"./bytes\");\nvar hash_1 = require(\"./hash\");\nvar helpers_1 = require(\"./helpers\");\nvar types_1 = require(\"./types\");\nvar Account = /** @class */function () {\n  /**\n   * This constructor assigns and validates the values.\n   * Use the static factory methods to assist in creating an Account from varying data types.\n   */\n  function Account(nonce, balance, stateRoot, codeHash) {\n    if (nonce === void 0) {\n      nonce = new externals_1.BN(0);\n    }\n    if (balance === void 0) {\n      balance = new externals_1.BN(0);\n    }\n    if (stateRoot === void 0) {\n      stateRoot = constants_1.KECCAK256_RLP;\n    }\n    if (codeHash === void 0) {\n      codeHash = constants_1.KECCAK256_NULL;\n    }\n    this.nonce = nonce;\n    this.balance = balance;\n    this.stateRoot = stateRoot;\n    this.codeHash = codeHash;\n    this._validate();\n  }\n  Account.fromAccountData = function (accountData) {\n    var nonce = accountData.nonce,\n      balance = accountData.balance,\n      stateRoot = accountData.stateRoot,\n      codeHash = accountData.codeHash;\n    return new Account(nonce ? new externals_1.BN((0, bytes_1.toBuffer)(nonce)) : undefined, balance ? new externals_1.BN((0, bytes_1.toBuffer)(balance)) : undefined, stateRoot ? (0, bytes_1.toBuffer)(stateRoot) : undefined, codeHash ? (0, bytes_1.toBuffer)(codeHash) : undefined);\n  };\n  Account.fromRlpSerializedAccount = function (serialized) {\n    var values = externals_1.rlp.decode(serialized);\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized account input. Must be array');\n    }\n    return this.fromValuesArray(values);\n  };\n  Account.fromValuesArray = function (values) {\n    var _a = __read(values, 4),\n      nonce = _a[0],\n      balance = _a[1],\n      stateRoot = _a[2],\n      codeHash = _a[3];\n    return new Account(new externals_1.BN(nonce), new externals_1.BN(balance), stateRoot, codeHash);\n  };\n  Account.prototype._validate = function () {\n    if (this.nonce.lt(new externals_1.BN(0))) {\n      throw new Error('nonce must be greater than zero');\n    }\n    if (this.balance.lt(new externals_1.BN(0))) {\n      throw new Error('balance must be greater than zero');\n    }\n    if (this.stateRoot.length !== 32) {\n      throw new Error('stateRoot must have a length of 32');\n    }\n    if (this.codeHash.length !== 32) {\n      throw new Error('codeHash must have a length of 32');\n    }\n  };\n  /**\n   * Returns a Buffer Array of the raw Buffers for the account, in order.\n   */\n  Account.prototype.raw = function () {\n    return [(0, types_1.bnToUnpaddedBuffer)(this.nonce), (0, types_1.bnToUnpaddedBuffer)(this.balance), this.stateRoot, this.codeHash];\n  };\n  /**\n   * Returns the RLP serialization of the account as a `Buffer`.\n   */\n  Account.prototype.serialize = function () {\n    return externals_1.rlp.encode(this.raw());\n  };\n  /**\n   * Returns a `Boolean` determining if the account is a contract.\n   */\n  Account.prototype.isContract = function () {\n    return !this.codeHash.equals(constants_1.KECCAK256_NULL);\n  };\n  /**\n   * Returns a `Boolean` determining if the account is empty complying to the definition of\n   * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n   * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n   */\n  Account.prototype.isEmpty = function () {\n    return this.balance.isZero() && this.nonce.isZero() && this.codeHash.equals(constants_1.KECCAK256_NULL);\n  };\n  return Account;\n}();\nexports.Account = Account;\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\nvar isValidAddress = function (hexAddress) {\n  try {\n    (0, helpers_1.assertIsString)(hexAddress);\n  } catch (e) {\n    return false;\n  }\n  return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\n};\nexports.isValidAddress = isValidAddress;\n/**\n * Returns a checksummed address.\n *\n * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not\n * backwards compatible to the original widely adopted checksum format standard introduced in\n * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.\n * Usage of this EIP is therefore discouraged unless you have a very targeted use case.\n */\nvar toChecksumAddress = function (hexAddress, eip1191ChainId) {\n  (0, helpers_1.assertIsHexString)(hexAddress);\n  var address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();\n  var prefix = '';\n  if (eip1191ChainId) {\n    var chainId = (0, types_1.toType)(eip1191ChainId, types_1.TypeOutput.BN);\n    prefix = chainId.toString() + '0x';\n  }\n  var hash = (0, hash_1.keccakFromString)(prefix + address).toString('hex');\n  var ret = '0x';\n  for (var i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += address[i].toUpperCase();\n    } else {\n      ret += address[i];\n    }\n  }\n  return ret;\n};\nexports.toChecksumAddress = toChecksumAddress;\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\nvar isValidChecksumAddress = function (hexAddress, eip1191ChainId) {\n  return (0, exports.isValidAddress)(hexAddress) && (0, exports.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;\n};\nexports.isValidChecksumAddress = isValidChecksumAddress;\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\nvar generateAddress = function (from, nonce) {\n  (0, helpers_1.assertIsBuffer)(from);\n  (0, helpers_1.assertIsBuffer)(nonce);\n  var nonceBN = new externals_1.BN(nonce);\n  if (nonceBN.isZero()) {\n    // in RLP we want to encode null in the case of zero nonce\n    // read the RLP documentation for an answer if you dare\n    return (0, hash_1.rlphash)([from, null]).slice(-20);\n  }\n  // Only take the lower 160bits of the hash\n  return (0, hash_1.rlphash)([from, Buffer.from(nonceBN.toArray())]).slice(-20);\n};\nexports.generateAddress = generateAddress;\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\nvar generateAddress2 = function (from, salt, initCode) {\n  (0, helpers_1.assertIsBuffer)(from);\n  (0, helpers_1.assertIsBuffer)(salt);\n  (0, helpers_1.assertIsBuffer)(initCode);\n  (0, assert_1.default)(from.length === 20);\n  (0, assert_1.default)(salt.length === 32);\n  var address = (0, hash_1.keccak256)(Buffer.concat([Buffer.from('ff', 'hex'), from, salt, (0, hash_1.keccak256)(initCode)]));\n  return address.slice(-20);\n};\nexports.generateAddress2 = generateAddress2;\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\nvar isValidPrivate = function (privateKey) {\n  return (0, secp256k1_1.privateKeyVerify)(privateKey);\n};\nexports.isValidPrivate = isValidPrivate;\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nvar isValidPublic = function (publicKey, sanitize) {\n  if (sanitize === void 0) {\n    sanitize = false;\n  }\n  (0, helpers_1.assertIsBuffer)(publicKey);\n  if (publicKey.length === 64) {\n    // Convert to SEC1 for secp256k1\n    return (0, secp256k1_1.publicKeyVerify)(Buffer.concat([Buffer.from([4]), publicKey]));\n  }\n  if (!sanitize) {\n    return false;\n  }\n  return (0, secp256k1_1.publicKeyVerify)(publicKey);\n};\nexports.isValidPublic = isValidPublic;\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nvar pubToAddress = function (pubKey, sanitize) {\n  if (sanitize === void 0) {\n    sanitize = false;\n  }\n  (0, helpers_1.assertIsBuffer)(pubKey);\n  if (sanitize && pubKey.length !== 64) {\n    pubKey = Buffer.from((0, secp256k1_1.publicKeyConvert)(pubKey, false).slice(1));\n  }\n  (0, assert_1.default)(pubKey.length === 64);\n  // Only take the lower 160bits of the hash\n  return (0, hash_1.keccak)(pubKey).slice(-20);\n};\nexports.pubToAddress = pubToAddress;\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nvar privateToPublic = function (privateKey) {\n  (0, helpers_1.assertIsBuffer)(privateKey);\n  // skip the type flag and use the X, Y points\n  return Buffer.from((0, secp256k1_1.publicKeyCreate)(privateKey, false)).slice(1);\n};\nexports.privateToPublic = privateToPublic;\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nvar privateToAddress = function (privateKey) {\n  return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));\n};\nexports.privateToAddress = privateToAddress;\n/**\n * Converts a public key to the Ethereum format.\n */\nvar importPublic = function (publicKey) {\n  (0, helpers_1.assertIsBuffer)(publicKey);\n  if (publicKey.length !== 64) {\n    publicKey = Buffer.from((0, secp256k1_1.publicKeyConvert)(publicKey, false).slice(1));\n  }\n  return publicKey;\n};\nexports.importPublic = importPublic;\n/**\n * Returns the zero address.\n */\nvar zeroAddress = function () {\n  var addressLength = 20;\n  var addr = (0, bytes_1.zeros)(addressLength);\n  return (0, bytes_1.bufferToHex)(addr);\n};\nexports.zeroAddress = zeroAddress;\n/**\n * Checks if a given address is the zero address.\n */\nvar isZeroAddress = function (hexAddress) {\n  try {\n    (0, helpers_1.assertIsString)(hexAddress);\n  } catch (e) {\n    return false;\n  }\n  var zeroAddr = (0, exports.zeroAddress)();\n  return zeroAddr === hexAddress;\n};\nexports.isZeroAddress = isZeroAddress;","map":{"version":3,"names":["assert_1","__importDefault","require","externals_1","secp256k1_1","internal_1","constants_1","bytes_1","hash_1","helpers_1","types_1","Account","nonce","balance","stateRoot","codeHash","BN","KECCAK256_RLP","KECCAK256_NULL","_validate","fromAccountData","accountData","toBuffer","undefined","fromRlpSerializedAccount","serialized","values","rlp","decode","Array","isArray","Error","fromValuesArray","_a","__read","prototype","lt","length","raw","bnToUnpaddedBuffer","serialize","encode","isContract","equals","isEmpty","isZero","exports","isValidAddress","hexAddress","assertIsString","e","test","toChecksumAddress","eip1191ChainId","assertIsHexString","address","stripHexPrefix","toLowerCase","prefix","chainId","toType","TypeOutput","toString","hash","keccakFromString","ret","i","parseInt","toUpperCase","isValidChecksumAddress","generateAddress","from","assertIsBuffer","nonceBN","rlphash","slice","Buffer","toArray","generateAddress2","salt","initCode","default","keccak256","concat","isValidPrivate","privateKey","privateKeyVerify","isValidPublic","publicKey","sanitize","publicKeyVerify","pubToAddress","pubKey","publicKeyConvert","keccak","publicToAddress","privateToPublic","publicKeyCreate","privateToAddress","importPublic","zeroAddress","addressLength","addr","zeros","bufferToHex","isZeroAddress","zeroAddr"],"sources":["../src/account.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script"}