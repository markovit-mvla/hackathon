{"ast":null,"code":"/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file subscription.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\"use strict\";\n\nvar errors = require('web3-core-helpers').errors;\nvar EventEmitter = require('eventemitter3');\nvar formatters = require('web3-core-helpers').formatters;\nfunction identity(value) {\n  return value;\n}\nfunction Subscription(options) {\n  EventEmitter.call(this);\n  this.id = null;\n  this.callback = identity;\n  this.arguments = null;\n  this.lastBlock = null; // \"from\" block tracker for backfilling events on reconnection\n  this.options = {\n    subscription: options.subscription,\n    type: options.type,\n    requestManager: options.requestManager\n  };\n}\n// INHERIT\nSubscription.prototype = Object.create(EventEmitter.prototype);\nSubscription.prototype.constructor = Subscription;\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\nSubscription.prototype._extractCallback = function (args) {\n  if (typeof args[args.length - 1] === 'function') {\n    return args.pop(); // modify the args array!\n  }\n};\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\nSubscription.prototype._validateArgs = function (args) {\n  var subscription = this.options.subscription;\n  if (!subscription) subscription = {};\n  if (!subscription.params) subscription.params = 0;\n  if (args.length !== subscription.params) {\n    throw errors.InvalidNumberOfParams(args.length, subscription.params, subscription.subscriptionName);\n  }\n};\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\nSubscription.prototype._formatInput = function (args) {\n  var subscription = this.options.subscription;\n  if (!subscription) {\n    return args;\n  }\n  if (!subscription.inputFormatter) {\n    return args;\n  }\n  var formattedArgs = subscription.inputFormatter.map(function (formatter, index) {\n    return formatter ? formatter(args[index]) : args[index];\n  });\n  return formattedArgs;\n};\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param result {Object}\n * @return {Object}\n */\nSubscription.prototype._formatOutput = function (result) {\n  var subscription = this.options.subscription;\n  return subscription && subscription.outputFormatter && result ? subscription.outputFormatter(result) : result;\n};\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\nSubscription.prototype._toPayload = function (args) {\n  var params = [];\n  this.callback = this._extractCallback(args) || identity;\n  if (!this.subscriptionMethod) {\n    this.subscriptionMethod = args.shift();\n    // replace subscription with given name\n    if (this.options.subscription.subscriptionName) {\n      this.subscriptionMethod = this.options.subscription.subscriptionName;\n    }\n  }\n  if (!this.arguments) {\n    this.arguments = this._formatInput(args);\n    this._validateArgs(this.arguments);\n    args = []; // make empty after validation\n  }\n  // re-add subscriptionName\n  params.push(this.subscriptionMethod);\n  params = params.concat(this.arguments);\n  if (args.length) {\n    throw new Error('Only a callback is allowed as parameter on an already instantiated subscription.');\n  }\n  return {\n    method: this.options.type + '_subscribe',\n    params: params\n  };\n};\n/**\n * Unsubscribes and clears callbacks\n *\n * @method unsubscribe\n * @return {Object}\n */\nSubscription.prototype.unsubscribe = function (callback) {\n  this.options.requestManager.removeSubscription(this.id, callback);\n  this.id = null;\n  this.lastBlock = null;\n  this.removeAllListeners();\n};\n/**\n * Subscribes and watches for changes\n *\n * @method subscribe\n * @param {String} subscription the subscription\n * @param {Object} options the options object with address topics and fromBlock\n * @return {Object}\n */\nSubscription.prototype.subscribe = function () {\n  var _this = this;\n  var args = Array.prototype.slice.call(arguments);\n  var payload = this._toPayload(args);\n  if (!payload) {\n    return this;\n  }\n  // throw error, if provider is not set\n  if (!this.options.requestManager.provider) {\n    setTimeout(function () {\n      var err1 = new Error('No provider set.');\n      _this.callback(err1, null, _this);\n      _this.emit('error', err1);\n    }, 0);\n    return this;\n  }\n  // throw error, if provider doesnt support subscriptions\n  if (!this.options.requestManager.provider.on) {\n    setTimeout(function () {\n      var err2 = new Error('The current provider doesn\\'t support subscriptions: ' + _this.options.requestManager.provider.constructor.name);\n      _this.callback(err2, null, _this);\n      _this.emit('error', err2);\n    }, 0);\n    return this;\n  }\n  // Re-subscription only: continue fetching from the last block we received.\n  // a dropped connection may have resulted in gaps in the logs...\n  if (this.lastBlock && !!this.options.params && typeof this.options.params === 'object') {\n    payload.params[1] = this.options.params;\n    payload.params[1].fromBlock = formatters.inputBlockNumberFormatter(this.lastBlock + 1);\n  }\n  // if id is there unsubscribe first\n  if (this.id) {\n    this.unsubscribe();\n  }\n  // store the params in the options object\n  this.options.params = payload.params[1];\n  // get past logs, if fromBlock is available\n  if (payload.params[0] === 'logs' && !!payload.params[1] && typeof payload.params[1] === 'object' && payload.params[1].hasOwnProperty('fromBlock') && isFinite(payload.params[1].fromBlock)) {\n    // send the subscription request\n    // copy the params to avoid race-condition with deletion below this block\n    var blockParams = Object.assign({}, payload.params[1]);\n    this.options.requestManager.send({\n      method: 'eth_getLogs',\n      params: [blockParams]\n    }, function (err, logs) {\n      if (!err) {\n        logs.forEach(function (log) {\n          var output = _this._formatOutput(log);\n          _this.callback(null, output, _this);\n          _this.emit('data', output);\n        });\n        // TODO subscribe here? after the past logs?\n      } else {\n        setTimeout(function () {\n          _this.callback(err, null, _this);\n          _this.emit('error', err);\n        }, 0);\n      }\n    });\n  }\n  // create subscription\n  // TODO move to separate function? so that past logs can go first?\n  if (typeof payload.params[1] === 'object') delete payload.params[1].fromBlock;\n  this.options.requestManager.send(payload, function (err, result) {\n    if (!err && result) {\n      _this.id = result;\n      _this.method = payload.params[0];\n      // call callback on notifications\n      _this.options.requestManager.addSubscription(_this, function (error, result) {\n        if (!error) {\n          if (!Array.isArray(result)) {\n            result = [result];\n          }\n          result.forEach(function (resultItem) {\n            var output = _this._formatOutput(resultItem);\n            // Track current block (for gaps introduced by dropped connections)\n            _this.lastBlock = !!output && typeof output === 'object' ? output.blockNumber : null;\n            if (typeof _this.options.subscription.subscriptionHandler === 'function') {\n              return _this.options.subscription.subscriptionHandler.call(_this, output);\n            } else {\n              _this.emit('data', output);\n            }\n            // call the callback, last so that unsubscribe there won't affect the emit above\n            _this.callback(null, output, _this);\n          });\n        } else {\n          _this.callback(error, false, _this);\n          _this.emit('error', error);\n        }\n      });\n      _this.emit('connected', result);\n    } else {\n      setTimeout(function () {\n        _this.callback(err, false, _this);\n        _this.emit('error', err);\n      }, 0);\n    }\n  });\n  // return an object to cancel the subscription\n  return this;\n};\n/**\n * Resubscribe\n *\n * @method resubscribe\n *\n * @returns {void}\n */\nSubscription.prototype.resubscribe = function () {\n  this.options.requestManager.removeSubscription(this.id); // unsubscribe\n  this.id = null;\n  this.subscribe(this.callback);\n};\nmodule.exports = Subscription;","map":{"version":3,"names":["errors","require","EventEmitter","formatters","identity","value","Subscription","options","call","id","callback","arguments","lastBlock","subscription","type","requestManager","prototype","Object","create","constructor","_extractCallback","args","length","pop","_validateArgs","params","InvalidNumberOfParams","subscriptionName","_formatInput","inputFormatter","formattedArgs","map","formatter","index","_formatOutput","result","outputFormatter","_toPayload","subscriptionMethod","shift","push","concat","Error","method","unsubscribe","removeSubscription","removeAllListeners","subscribe","_this","Array","slice","payload","provider","setTimeout","err1","emit","on","err2","name","fromBlock","inputBlockNumberFormatter","hasOwnProperty","isFinite","blockParams","assign","send","err","logs","forEach","log","output","addSubscription","error","isArray","resultItem","blockNumber","subscriptionHandler","resubscribe","module","exports"],"sources":["C:/Users/jack/git/hackathon/starter-files/node_modules/web3-core-subscriptions/lib/subscription.js"],"sourcesContent":["/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file subscription.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\"use strict\";\nvar errors = require('web3-core-helpers').errors;\nvar EventEmitter = require('eventemitter3');\nvar formatters = require('web3-core-helpers').formatters;\nfunction identity(value) {\n    return value;\n}\nfunction Subscription(options) {\n    EventEmitter.call(this);\n    this.id = null;\n    this.callback = identity;\n    this.arguments = null;\n    this.lastBlock = null; // \"from\" block tracker for backfilling events on reconnection\n    this.options = {\n        subscription: options.subscription,\n        type: options.type,\n        requestManager: options.requestManager\n    };\n}\n// INHERIT\nSubscription.prototype = Object.create(EventEmitter.prototype);\nSubscription.prototype.constructor = Subscription;\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\nSubscription.prototype._extractCallback = function (args) {\n    if (typeof args[args.length - 1] === 'function') {\n        return args.pop(); // modify the args array!\n    }\n};\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\nSubscription.prototype._validateArgs = function (args) {\n    var subscription = this.options.subscription;\n    if (!subscription)\n        subscription = {};\n    if (!subscription.params)\n        subscription.params = 0;\n    if (args.length !== subscription.params) {\n        throw errors.InvalidNumberOfParams(args.length, subscription.params, subscription.subscriptionName);\n    }\n};\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\nSubscription.prototype._formatInput = function (args) {\n    var subscription = this.options.subscription;\n    if (!subscription) {\n        return args;\n    }\n    if (!subscription.inputFormatter) {\n        return args;\n    }\n    var formattedArgs = subscription.inputFormatter.map(function (formatter, index) {\n        return formatter ? formatter(args[index]) : args[index];\n    });\n    return formattedArgs;\n};\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param result {Object}\n * @return {Object}\n */\nSubscription.prototype._formatOutput = function (result) {\n    var subscription = this.options.subscription;\n    return (subscription && subscription.outputFormatter && result) ? subscription.outputFormatter(result) : result;\n};\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\nSubscription.prototype._toPayload = function (args) {\n    var params = [];\n    this.callback = this._extractCallback(args) || identity;\n    if (!this.subscriptionMethod) {\n        this.subscriptionMethod = args.shift();\n        // replace subscription with given name\n        if (this.options.subscription.subscriptionName) {\n            this.subscriptionMethod = this.options.subscription.subscriptionName;\n        }\n    }\n    if (!this.arguments) {\n        this.arguments = this._formatInput(args);\n        this._validateArgs(this.arguments);\n        args = []; // make empty after validation\n    }\n    // re-add subscriptionName\n    params.push(this.subscriptionMethod);\n    params = params.concat(this.arguments);\n    if (args.length) {\n        throw new Error('Only a callback is allowed as parameter on an already instantiated subscription.');\n    }\n    return {\n        method: this.options.type + '_subscribe',\n        params: params\n    };\n};\n/**\n * Unsubscribes and clears callbacks\n *\n * @method unsubscribe\n * @return {Object}\n */\nSubscription.prototype.unsubscribe = function (callback) {\n    this.options.requestManager.removeSubscription(this.id, callback);\n    this.id = null;\n    this.lastBlock = null;\n    this.removeAllListeners();\n};\n/**\n * Subscribes and watches for changes\n *\n * @method subscribe\n * @param {String} subscription the subscription\n * @param {Object} options the options object with address topics and fromBlock\n * @return {Object}\n */\nSubscription.prototype.subscribe = function () {\n    var _this = this;\n    var args = Array.prototype.slice.call(arguments);\n    var payload = this._toPayload(args);\n    if (!payload) {\n        return this;\n    }\n    // throw error, if provider is not set\n    if (!this.options.requestManager.provider) {\n        setTimeout(function () {\n            var err1 = new Error('No provider set.');\n            _this.callback(err1, null, _this);\n            _this.emit('error', err1);\n        }, 0);\n        return this;\n    }\n    // throw error, if provider doesnt support subscriptions\n    if (!this.options.requestManager.provider.on) {\n        setTimeout(function () {\n            var err2 = new Error('The current provider doesn\\'t support subscriptions: ' +\n                _this.options.requestManager.provider.constructor.name);\n            _this.callback(err2, null, _this);\n            _this.emit('error', err2);\n        }, 0);\n        return this;\n    }\n    // Re-subscription only: continue fetching from the last block we received.\n    // a dropped connection may have resulted in gaps in the logs...\n    if (this.lastBlock && !!this.options.params && typeof this.options.params === 'object') {\n        payload.params[1] = this.options.params;\n        payload.params[1].fromBlock = formatters.inputBlockNumberFormatter(this.lastBlock + 1);\n    }\n    // if id is there unsubscribe first\n    if (this.id) {\n        this.unsubscribe();\n    }\n    // store the params in the options object\n    this.options.params = payload.params[1];\n    // get past logs, if fromBlock is available\n    if (payload.params[0] === 'logs' && !!payload.params[1] && typeof payload.params[1] === 'object' && payload.params[1].hasOwnProperty('fromBlock') && isFinite(payload.params[1].fromBlock)) {\n        // send the subscription request\n        // copy the params to avoid race-condition with deletion below this block\n        var blockParams = Object.assign({}, payload.params[1]);\n        this.options.requestManager.send({\n            method: 'eth_getLogs',\n            params: [blockParams]\n        }, function (err, logs) {\n            if (!err) {\n                logs.forEach(function (log) {\n                    var output = _this._formatOutput(log);\n                    _this.callback(null, output, _this);\n                    _this.emit('data', output);\n                });\n                // TODO subscribe here? after the past logs?\n            }\n            else {\n                setTimeout(function () {\n                    _this.callback(err, null, _this);\n                    _this.emit('error', err);\n                }, 0);\n            }\n        });\n    }\n    // create subscription\n    // TODO move to separate function? so that past logs can go first?\n    if (typeof payload.params[1] === 'object')\n        delete payload.params[1].fromBlock;\n    this.options.requestManager.send(payload, function (err, result) {\n        if (!err && result) {\n            _this.id = result;\n            _this.method = payload.params[0];\n            // call callback on notifications\n            _this.options.requestManager.addSubscription(_this, function (error, result) {\n                if (!error) {\n                    if (!Array.isArray(result)) {\n                        result = [result];\n                    }\n                    result.forEach(function (resultItem) {\n                        var output = _this._formatOutput(resultItem);\n                        // Track current block (for gaps introduced by dropped connections)\n                        _this.lastBlock = !!output && typeof output === 'object' ? output.blockNumber : null;\n                        if (typeof _this.options.subscription.subscriptionHandler === 'function') {\n                            return _this.options.subscription.subscriptionHandler.call(_this, output);\n                        }\n                        else {\n                            _this.emit('data', output);\n                        }\n                        // call the callback, last so that unsubscribe there won't affect the emit above\n                        _this.callback(null, output, _this);\n                    });\n                }\n                else {\n                    _this.callback(error, false, _this);\n                    _this.emit('error', error);\n                }\n            });\n            _this.emit('connected', result);\n        }\n        else {\n            setTimeout(function () {\n                _this.callback(err, false, _this);\n                _this.emit('error', err);\n            }, 0);\n        }\n    });\n    // return an object to cancel the subscription\n    return this;\n};\n/**\n * Resubscribe\n *\n * @method resubscribe\n *\n * @returns {void}\n */\nSubscription.prototype.resubscribe = function () {\n    this.options.requestManager.removeSubscription(this.id); // unsubscribe\n    this.id = null;\n    this.subscribe(this.callback);\n};\nmodule.exports = Subscription;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}