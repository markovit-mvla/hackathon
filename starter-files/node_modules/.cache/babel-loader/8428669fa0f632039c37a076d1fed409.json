{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"./utils\");\n/**\r\n * Returns true if the bloom is a valid bloom\r\n * @param bloom The bloom\r\n */\nfunction isBloom(bloom) {\n  if (typeof bloom !== 'string') {\n    return false;\n  }\n  if (!/^(0x)?[0-9a-f]{512}$/i.test(bloom)) {\n    return false;\n  }\n  if (/^(0x)?[0-9a-f]{512}$/.test(bloom) || /^(0x)?[0-9A-F]{512}$/.test(bloom)) {\n    return true;\n  }\n  return false;\n}\nexports.isBloom = isBloom;\n/**\r\n * Returns true if the value is part of the given bloom\r\n * note: false positives are possible.\r\n * @param bloom encoded bloom\r\n * @param value The value\r\n */\nfunction isInBloom(bloom, value) {\n  if (typeof value === 'object' && value.constructor === Uint8Array) {\n    value = utils_1.bytesToHex(value);\n  }\n  const hash = utils_1.keccak256(value).replace('0x', '');\n  for (let i = 0; i < 12; i += 4) {\n    // calculate bit position in bloom filter that must be active\n    const bitpos = (parseInt(hash.substr(i, 2), 16) << 8) + parseInt(hash.substr(i + 2, 2), 16) & 2047;\n    // test if bitpos in bloom is active\n    const code = codePointToInt(bloom.charCodeAt(bloom.length - 1 - Math.floor(bitpos / 4)));\n    const offset = 1 << bitpos % 4;\n    if ((code & offset) !== offset) {\n      return false;\n    }\n  }\n  return true;\n}\nexports.isInBloom = isInBloom;\n/**\r\n * Code points to int\r\n * @param codePoint The code point\r\n */\nfunction codePointToInt(codePoint) {\n  if (codePoint >= 48 && codePoint <= 57) {\n    /* ['0'..'9'] -> [0..9] */\n    return codePoint - 48;\n  }\n  if (codePoint >= 65 && codePoint <= 70) {\n    /* ['A'..'F'] -> [10..15] */\n    return codePoint - 55;\n  }\n  if (codePoint >= 97 && codePoint <= 102) {\n    /* ['a'..'f'] -> [10..15] */\n    return codePoint - 87;\n  }\n  throw new Error('invalid bloom');\n}\n/**\r\n * Returns true if the ethereum users address is part of the given bloom.\r\n * note: false positives are possible.\r\n * @param bloom encoded bloom\r\n * @param address the address to test\r\n */\nfunction isUserEthereumAddressInBloom(bloom, ethereumAddress) {\n  if (!isBloom(bloom)) {\n    throw new Error('Invalid bloom given');\n  }\n  if (!isAddress(ethereumAddress)) {\n    throw new Error(`Invalid ethereum address given: \"${ethereumAddress}\"`);\n  }\n  // you have to pad the ethereum address to 32 bytes\n  // else the bloom filter does not work\n  // this is only if your matching the USERS\n  // ethereum address. Contract address do not need this\n  // hence why we have 2 methods\n  // (0x is not in the 2nd parameter of padleft so 64 chars is fine)\n  const address = utils_1.padLeft(ethereumAddress, 64);\n  return isInBloom(bloom, address);\n}\nexports.isUserEthereumAddressInBloom = isUserEthereumAddressInBloom;\n/**\r\n * Returns true if the contract address is part of the given bloom.\r\n * note: false positives are possible.\r\n * @param bloom encoded bloom\r\n * @param contractAddress the contract address to test\r\n */\nfunction isContractAddressInBloom(bloom, contractAddress) {\n  if (!isBloom(bloom)) {\n    throw new Error('Invalid bloom given');\n  }\n  if (!isAddress(contractAddress)) {\n    throw new Error(`Invalid contract address given: \"${contractAddress}\"`);\n  }\n  return isInBloom(bloom, contractAddress);\n}\nexports.isContractAddressInBloom = isContractAddressInBloom;\n/**\r\n * Returns true if the topic is part of the given bloom.\r\n * note: false positives are possible.\r\n * @param bloom encoded bloom\r\n * @param topic the topic encoded hex\r\n */\nfunction isTopicInBloom(bloom, topic) {\n  if (!isBloom(bloom)) {\n    throw new Error('Invalid bloom given');\n  }\n  if (!isTopic(topic)) {\n    throw new Error('Invalid topic');\n  }\n  return isInBloom(bloom, topic);\n}\nexports.isTopicInBloom = isTopicInBloom;\n/**\r\n * Checks if its a valid topic\r\n * @param topic encoded hex topic\r\n */\nfunction isTopic(topic) {\n  if (typeof topic !== 'string') {\n    return false;\n  }\n  if (!/^(0x)?[0-9a-f]{64}$/i.test(topic)) {\n    return false;\n  } else if (/^(0x)?[0-9a-f]{64}$/.test(topic) || /^(0x)?[0-9A-F]{64}$/.test(topic)) {\n    return true;\n  }\n  return false;\n}\nexports.isTopic = isTopic;\n/**\r\n * Is valid address\r\n * @param address The address\r\n */\nfunction isAddress(address) {\n  if (typeof address !== 'string') {\n    return false;\n  }\n  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n    return true;\n  }\n  if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n    return true;\n  }\n  return false;\n}\nexports.isAddress = isAddress;","map":{"version":3,"names":["Object","defineProperty","exports","value","utils_1","require","isBloom","bloom","test","isInBloom","constructor","Uint8Array","bytesToHex","hash","keccak256","replace","i","bitpos","parseInt","substr","code","codePointToInt","charCodeAt","length","Math","floor","offset","codePoint","Error","isUserEthereumAddressInBloom","ethereumAddress","isAddress","address","padLeft","isContractAddressInBloom","contractAddress","isTopicInBloom","topic","isTopic","match"],"sources":["C:/Users/jack/git/hackathon/starter-files/node_modules/ethereum-bloom-filters/dist/index.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst utils_1 = require(\"./utils\");\r\n/**\r\n * Returns true if the bloom is a valid bloom\r\n * @param bloom The bloom\r\n */\r\nfunction isBloom(bloom) {\r\n    if (typeof bloom !== 'string') {\r\n        return false;\r\n    }\r\n    if (!/^(0x)?[0-9a-f]{512}$/i.test(bloom)) {\r\n        return false;\r\n    }\r\n    if (/^(0x)?[0-9a-f]{512}$/.test(bloom) ||\r\n        /^(0x)?[0-9A-F]{512}$/.test(bloom)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nexports.isBloom = isBloom;\r\n/**\r\n * Returns true if the value is part of the given bloom\r\n * note: false positives are possible.\r\n * @param bloom encoded bloom\r\n * @param value The value\r\n */\r\nfunction isInBloom(bloom, value) {\r\n    if (typeof value === 'object' && value.constructor === Uint8Array) {\r\n        value = utils_1.bytesToHex(value);\r\n    }\r\n    const hash = utils_1.keccak256(value).replace('0x', '');\r\n    for (let i = 0; i < 12; i += 4) {\r\n        // calculate bit position in bloom filter that must be active\r\n        const bitpos = ((parseInt(hash.substr(i, 2), 16) << 8) +\r\n            parseInt(hash.substr(i + 2, 2), 16)) &\r\n            2047;\r\n        // test if bitpos in bloom is active\r\n        const code = codePointToInt(bloom.charCodeAt(bloom.length - 1 - Math.floor(bitpos / 4)));\r\n        const offset = 1 << bitpos % 4;\r\n        if ((code & offset) !== offset) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexports.isInBloom = isInBloom;\r\n/**\r\n * Code points to int\r\n * @param codePoint The code point\r\n */\r\nfunction codePointToInt(codePoint) {\r\n    if (codePoint >= 48 && codePoint <= 57) {\r\n        /* ['0'..'9'] -> [0..9] */\r\n        return codePoint - 48;\r\n    }\r\n    if (codePoint >= 65 && codePoint <= 70) {\r\n        /* ['A'..'F'] -> [10..15] */\r\n        return codePoint - 55;\r\n    }\r\n    if (codePoint >= 97 && codePoint <= 102) {\r\n        /* ['a'..'f'] -> [10..15] */\r\n        return codePoint - 87;\r\n    }\r\n    throw new Error('invalid bloom');\r\n}\r\n/**\r\n * Returns true if the ethereum users address is part of the given bloom.\r\n * note: false positives are possible.\r\n * @param bloom encoded bloom\r\n * @param address the address to test\r\n */\r\nfunction isUserEthereumAddressInBloom(bloom, ethereumAddress) {\r\n    if (!isBloom(bloom)) {\r\n        throw new Error('Invalid bloom given');\r\n    }\r\n    if (!isAddress(ethereumAddress)) {\r\n        throw new Error(`Invalid ethereum address given: \"${ethereumAddress}\"`);\r\n    }\r\n    // you have to pad the ethereum address to 32 bytes\r\n    // else the bloom filter does not work\r\n    // this is only if your matching the USERS\r\n    // ethereum address. Contract address do not need this\r\n    // hence why we have 2 methods\r\n    // (0x is not in the 2nd parameter of padleft so 64 chars is fine)\r\n    const address = utils_1.padLeft(ethereumAddress, 64);\r\n    return isInBloom(bloom, address);\r\n}\r\nexports.isUserEthereumAddressInBloom = isUserEthereumAddressInBloom;\r\n/**\r\n * Returns true if the contract address is part of the given bloom.\r\n * note: false positives are possible.\r\n * @param bloom encoded bloom\r\n * @param contractAddress the contract address to test\r\n */\r\nfunction isContractAddressInBloom(bloom, contractAddress) {\r\n    if (!isBloom(bloom)) {\r\n        throw new Error('Invalid bloom given');\r\n    }\r\n    if (!isAddress(contractAddress)) {\r\n        throw new Error(`Invalid contract address given: \"${contractAddress}\"`);\r\n    }\r\n    return isInBloom(bloom, contractAddress);\r\n}\r\nexports.isContractAddressInBloom = isContractAddressInBloom;\r\n/**\r\n * Returns true if the topic is part of the given bloom.\r\n * note: false positives are possible.\r\n * @param bloom encoded bloom\r\n * @param topic the topic encoded hex\r\n */\r\nfunction isTopicInBloom(bloom, topic) {\r\n    if (!isBloom(bloom)) {\r\n        throw new Error('Invalid bloom given');\r\n    }\r\n    if (!isTopic(topic)) {\r\n        throw new Error('Invalid topic');\r\n    }\r\n    return isInBloom(bloom, topic);\r\n}\r\nexports.isTopicInBloom = isTopicInBloom;\r\n/**\r\n * Checks if its a valid topic\r\n * @param topic encoded hex topic\r\n */\r\nfunction isTopic(topic) {\r\n    if (typeof topic !== 'string') {\r\n        return false;\r\n    }\r\n    if (!/^(0x)?[0-9a-f]{64}$/i.test(topic)) {\r\n        return false;\r\n    }\r\n    else if (/^(0x)?[0-9a-f]{64}$/.test(topic) ||\r\n        /^(0x)?[0-9A-F]{64}$/.test(topic)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nexports.isTopic = isTopic;\r\n/**\r\n * Is valid address\r\n * @param address The address\r\n */\r\nfunction isAddress(address) {\r\n    if (typeof address !== 'string') {\r\n        return false;\r\n    }\r\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\r\n        return true;\r\n    }\r\n    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nexports.isAddress = isAddress;\r\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7D,MAAMC,OAAO,GAAGC,OAAO,CAAC,SAAS,CAAC;AAClC;AACA;AACA;AACA;AACA,SAASC,OAAOA,CAACC,KAAK,EAAE;EACpB,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IAC3B,OAAO,KAAK;EAChB;EACA,IAAI,CAAC,uBAAuB,CAACC,IAAI,CAACD,KAAK,CAAC,EAAE;IACtC,OAAO,KAAK;EAChB;EACA,IAAI,sBAAsB,CAACC,IAAI,CAACD,KAAK,CAAC,IAClC,sBAAsB,CAACC,IAAI,CAACD,KAAK,CAAC,EAAE;IACpC,OAAO,IAAI;EACf;EACA,OAAO,KAAK;AAChB;AACAL,OAAO,CAACI,OAAO,GAAGA,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,SAASG,SAASA,CAACF,KAAK,EAAEJ,KAAK,EAAE;EAC7B,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAIA,KAAK,CAACO,WAAW,KAAKC,UAAU,EAAE;IAC/DR,KAAK,GAAGC,OAAO,CAACQ,UAAU,CAACT,KAAK,CAAC;EACrC;EACA,MAAMU,IAAI,GAAGT,OAAO,CAACU,SAAS,CAACX,KAAK,CAAC,CAACY,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC;EACvD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAEA,CAAC,IAAI,CAAC,EAAE;IAC5B;IACA,MAAMC,MAAM,GAAI,CAACC,QAAQ,CAACL,IAAI,CAACM,MAAM,CAACH,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,IACjDE,QAAQ,CAACL,IAAI,CAACM,MAAM,CAACH,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,GACnC,IAAI;IACR;IACA,MAAMI,IAAI,GAAGC,cAAc,CAACd,KAAK,CAACe,UAAU,CAACf,KAAK,CAACgB,MAAM,GAAG,CAAC,GAAGC,IAAI,CAACC,KAAK,CAACR,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;IACxF,MAAMS,MAAM,GAAG,CAAC,IAAIT,MAAM,GAAG,CAAC;IAC9B,IAAI,CAACG,IAAI,GAAGM,MAAM,MAAMA,MAAM,EAAE;MAC5B,OAAO,KAAK;IAChB;EACJ;EACA,OAAO,IAAI;AACf;AACAxB,OAAO,CAACO,SAAS,GAAGA,SAAS;AAC7B;AACA;AACA;AACA;AACA,SAASY,cAAcA,CAACM,SAAS,EAAE;EAC/B,IAAIA,SAAS,IAAI,EAAE,IAAIA,SAAS,IAAI,EAAE,EAAE;IACpC;IACA,OAAOA,SAAS,GAAG,EAAE;EACzB;EACA,IAAIA,SAAS,IAAI,EAAE,IAAIA,SAAS,IAAI,EAAE,EAAE;IACpC;IACA,OAAOA,SAAS,GAAG,EAAE;EACzB;EACA,IAAIA,SAAS,IAAI,EAAE,IAAIA,SAAS,IAAI,GAAG,EAAE;IACrC;IACA,OAAOA,SAAS,GAAG,EAAE;EACzB;EACA,MAAM,IAAIC,KAAK,CAAC,eAAe,CAAC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,4BAA4BA,CAACtB,KAAK,EAAEuB,eAAe,EAAE;EAC1D,IAAI,CAACxB,OAAO,CAACC,KAAK,CAAC,EAAE;IACjB,MAAM,IAAIqB,KAAK,CAAC,qBAAqB,CAAC;EAC1C;EACA,IAAI,CAACG,SAAS,CAACD,eAAe,CAAC,EAAE;IAC7B,MAAM,IAAIF,KAAK,CAAE,oCAAmCE,eAAgB,GAAE,CAAC;EAC3E;EACA;EACA;EACA;EACA;EACA;EACA;EACA,MAAME,OAAO,GAAG5B,OAAO,CAAC6B,OAAO,CAACH,eAAe,EAAE,EAAE,CAAC;EACpD,OAAOrB,SAAS,CAACF,KAAK,EAAEyB,OAAO,CAAC;AACpC;AACA9B,OAAO,CAAC2B,4BAA4B,GAAGA,4BAA4B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,SAASK,wBAAwBA,CAAC3B,KAAK,EAAE4B,eAAe,EAAE;EACtD,IAAI,CAAC7B,OAAO,CAACC,KAAK,CAAC,EAAE;IACjB,MAAM,IAAIqB,KAAK,CAAC,qBAAqB,CAAC;EAC1C;EACA,IAAI,CAACG,SAAS,CAACI,eAAe,CAAC,EAAE;IAC7B,MAAM,IAAIP,KAAK,CAAE,oCAAmCO,eAAgB,GAAE,CAAC;EAC3E;EACA,OAAO1B,SAAS,CAACF,KAAK,EAAE4B,eAAe,CAAC;AAC5C;AACAjC,OAAO,CAACgC,wBAAwB,GAAGA,wBAAwB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,cAAcA,CAAC7B,KAAK,EAAE8B,KAAK,EAAE;EAClC,IAAI,CAAC/B,OAAO,CAACC,KAAK,CAAC,EAAE;IACjB,MAAM,IAAIqB,KAAK,CAAC,qBAAqB,CAAC;EAC1C;EACA,IAAI,CAACU,OAAO,CAACD,KAAK,CAAC,EAAE;IACjB,MAAM,IAAIT,KAAK,CAAC,eAAe,CAAC;EACpC;EACA,OAAOnB,SAAS,CAACF,KAAK,EAAE8B,KAAK,CAAC;AAClC;AACAnC,OAAO,CAACkC,cAAc,GAAGA,cAAc;AACvC;AACA;AACA;AACA;AACA,SAASE,OAAOA,CAACD,KAAK,EAAE;EACpB,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IAC3B,OAAO,KAAK;EAChB;EACA,IAAI,CAAC,sBAAsB,CAAC7B,IAAI,CAAC6B,KAAK,CAAC,EAAE;IACrC,OAAO,KAAK;EAChB,CAAC,MACI,IAAI,qBAAqB,CAAC7B,IAAI,CAAC6B,KAAK,CAAC,IACtC,qBAAqB,CAAC7B,IAAI,CAAC6B,KAAK,CAAC,EAAE;IACnC,OAAO,IAAI;EACf;EACA,OAAO,KAAK;AAChB;AACAnC,OAAO,CAACoC,OAAO,GAAGA,OAAO;AACzB;AACA;AACA;AACA;AACA,SAASP,SAASA,CAACC,OAAO,EAAE;EACxB,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;IAC7B,OAAO,KAAK;EAChB;EACA,IAAIA,OAAO,CAACO,KAAK,CAAC,wBAAwB,CAAC,EAAE;IACzC,OAAO,IAAI;EACf;EACA,IAAIP,OAAO,CAACO,KAAK,CAAC,gCAAgC,CAAC,EAAE;IACjD,OAAO,IAAI;EACf;EACA,OAAO,KAAK;AAChB;AACArC,OAAO,CAAC6B,SAAS,GAAGA,SAAS"},"metadata":{},"sourceType":"script"}