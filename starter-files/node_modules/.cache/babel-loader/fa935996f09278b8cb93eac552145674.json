{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defineProperties = void 0;\nvar assert_1 = __importDefault(require(\"assert\"));\nvar internal_1 = require(\"./internal\");\nvar externals_1 = require(\"./externals\");\nvar bytes_1 = require(\"./bytes\");\n/**\n * Defines properties on a `Object`. It make the assumption that underlying data is binary.\n * @param self the `Object` to define properties on\n * @param fields an array fields to define. Fields can contain:\n * * `name` - the name of the properties\n * * `length` - the number of bytes the field can have\n * * `allowLess` - if the field can be less than the length\n * * `allowEmpty`\n * @param data data to be validated against the definitions\n * @deprecated\n */\nvar defineProperties = function (self, fields, data) {\n  self.raw = [];\n  self._fields = [];\n  // attach the `toJSON`\n  self.toJSON = function (label) {\n    if (label === void 0) {\n      label = false;\n    }\n    if (label) {\n      var obj_1 = {};\n      self._fields.forEach(function (field) {\n        obj_1[field] = \"0x\".concat(self[field].toString('hex'));\n      });\n      return obj_1;\n    }\n    return (0, bytes_1.baToJSON)(self.raw);\n  };\n  self.serialize = function serialize() {\n    return externals_1.rlp.encode(self.raw);\n  };\n  fields.forEach(function (field, i) {\n    self._fields.push(field.name);\n    function getter() {\n      return self.raw[i];\n    }\n    function setter(v) {\n      v = (0, bytes_1.toBuffer)(v);\n      if (v.toString('hex') === '00' && !field.allowZero) {\n        v = Buffer.allocUnsafe(0);\n      }\n      if (field.allowLess && field.length) {\n        v = (0, bytes_1.unpadBuffer)(v);\n        (0, assert_1.default)(field.length >= v.length, \"The field \".concat(field.name, \" must not have more \").concat(field.length, \" bytes\"));\n      } else if (!(field.allowZero && v.length === 0) && field.length) {\n        (0, assert_1.default)(field.length === v.length, \"The field \".concat(field.name, \" must have byte length of \").concat(field.length));\n      }\n      self.raw[i] = v;\n    }\n    Object.defineProperty(self, field.name, {\n      enumerable: true,\n      configurable: true,\n      get: getter,\n      set: setter\n    });\n    if (field.default) {\n      self[field.name] = field.default;\n    }\n    // attach alias\n    if (field.alias) {\n      Object.defineProperty(self, field.alias, {\n        enumerable: false,\n        configurable: true,\n        set: setter,\n        get: getter\n      });\n    }\n  });\n  // if the constuctor is passed data\n  if (data) {\n    if (typeof data === 'string') {\n      data = Buffer.from((0, internal_1.stripHexPrefix)(data), 'hex');\n    }\n    if (Buffer.isBuffer(data)) {\n      data = externals_1.rlp.decode(data);\n    }\n    if (Array.isArray(data)) {\n      if (data.length > self._fields.length) {\n        throw new Error('wrong number of fields in data');\n      }\n      // make sure all the items are buffers\n      data.forEach(function (d, i) {\n        self[self._fields[i]] = (0, bytes_1.toBuffer)(d);\n      });\n    } else if (typeof data === 'object') {\n      var keys_1 = Object.keys(data);\n      fields.forEach(function (field) {\n        if (keys_1.indexOf(field.name) !== -1) self[field.name] = data[field.name];\n        if (keys_1.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];\n      });\n    } else {\n      throw new Error('invalid data');\n    }\n  }\n};\nexports.defineProperties = defineProperties;","map":{"version":3,"names":["assert_1","__importDefault","require","internal_1","externals_1","bytes_1","defineProperties","self","fields","data","raw","_fields","toJSON","label","obj_1","forEach","field","concat","toString","baToJSON","serialize","rlp","encode","i","push","name","getter","setter","v","toBuffer","allowZero","Buffer","allocUnsafe","allowLess","length","unpadBuffer","default","Object","defineProperty","enumerable","configurable","get","set","alias","from","stripHexPrefix","isBuffer","decode","Array","isArray","Error","d","keys_1","keys","indexOf","exports"],"sources":["../src/object.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script"}