{"ast":null,"code":"import { __read, __spreadArray, __values } from \"tslib\";\nimport { isResponse } from \"../types\";\nexport function makeWebSocketSender(ws) {\n  var contextsById = new Map();\n  ws.addEventListener(\"message\", function (message) {\n    var response = JSON.parse(message.data);\n    if (!isResponse(response)) {\n      return;\n    }\n    var id = getIdFromResponse(response);\n    if (id === undefined) {\n      return;\n    }\n    var context = contextsById.get(id);\n    if (!context) {\n      return;\n    }\n    var resolve = context.resolve;\n    contextsById.delete(id);\n    if (!Array.isArray(response) && response.error && response.error.code === 429) {\n      resolve({\n        type: \"rateLimit\"\n      });\n    } else {\n      resolve({\n        response: response,\n        type: \"jsonrpc\"\n      });\n    }\n  });\n  ws.addEventListener(\"down\", function () {\n    __spreadArray([], __read(contextsById)).forEach(function (_a) {\n      var _b = __read(_a, 2),\n        id = _b[0],\n        _c = _b[1],\n        request = _c.request,\n        resolve = _c.resolve;\n      if (isWrite(request)) {\n        // Writes cannot be resent because they will fail for a duplicate nonce.\n        contextsById.delete(id);\n        resolve({\n          type: \"networkError\",\n          status: 0,\n          message: \"WebSocket closed before receiving a response for write request with id: \" + id + \".\"\n        });\n      }\n    });\n  });\n  ws.addEventListener(\"reopen\", function () {\n    var e_1, _a;\n    try {\n      for (var _b = __values(contextsById.values()), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var request = _c.value.request;\n        ws.send(JSON.stringify(request));\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  });\n  return function (request) {\n    return new Promise(function (resolve) {\n      var id = getIdFromRequest(request);\n      if (id !== undefined) {\n        var existingContext = contextsById.get(id);\n        if (existingContext) {\n          var message = \"Another WebSocket request was made with the same id (\" + id + \") before a response was received.\";\n          console.error(message);\n          existingContext.resolve({\n            message: message,\n            type: \"networkError\",\n            status: 0\n          });\n        }\n        contextsById.set(id, {\n          request: request,\n          resolve: resolve\n        });\n      }\n      ws.send(JSON.stringify(request));\n    });\n  };\n}\nfunction getIdFromRequest(request) {\n  if (!Array.isArray(request)) {\n    return request.id;\n  }\n  return getCanonicalIdFromList(request.map(function (p) {\n    return p.id;\n  }));\n}\nfunction getIdFromResponse(response) {\n  if (!Array.isArray(response)) {\n    return response.id;\n  }\n  return getCanonicalIdFromList(response.map(function (p) {\n    return p.id;\n  }));\n}\n/**\n * Since the JSON-RPC spec allows responses to be returned in a different order\n * than sent, we need a mechanism for choosing a canonical id from a list that\n * doesn't depend on the order. This chooses the \"minimum\" id by an arbitrary\n * ordering: the smallest string if possible, otherwise the smallest number,\n * otherwise null.\n */\nfunction getCanonicalIdFromList(ids) {\n  var stringIds = ids.filter(function (id) {\n    return typeof id === \"string\";\n  });\n  if (stringIds.length > 0) {\n    return stringIds.reduce(function (bestId, id) {\n      return bestId < id ? bestId : id;\n    });\n  }\n  var numberIds = ids.filter(function (id) {\n    return typeof id === \"number\";\n  });\n  if (numberIds.length > 0) {\n    return Math.min.apply(Math, __spreadArray([], __read(numberIds)));\n  }\n  return ids.indexOf(null) >= 0 ? null : undefined;\n}\nfunction isWrite(request) {\n  return Array.isArray(request) ? request.every(isSingleWrite) : isSingleWrite(request);\n}\nvar WRITE_METHODS = [\"eth_sendTransaction\", \"eth_sendRawTransaction\"];\nfunction isSingleWrite(request) {\n  return WRITE_METHODS.includes(request.method);\n}","map":{"version":3,"names":["isResponse","makeWebSocketSender","ws","contextsById","Map","addEventListener","message","response","JSON","parse","data","id","getIdFromResponse","undefined","context","get","resolve","delete","Array","isArray","error","code","type","__spreadArray","__read","forEach","_a","_b","_c","request","isWrite","status","__values","values","next","done","value","send","stringify","Promise","getIdFromRequest","existingContext","console","set","getCanonicalIdFromList","map","p","ids","stringIds","filter","length","reduce","bestId","numberIds","Math","min","apply","indexOf","every","isSingleWrite","WRITE_METHODS","includes","method"],"sources":["../../../src/web3-adapter/alchemySendWebSocket.ts"],"sourcesContent":["import SturdyWebSocket from \"sturdy-websocket\";\nimport {\n  isResponse,\n  JsonRpcId,\n  JsonRpcRequest,\n  SingleOrBatchRequest,\n  SingleOrBatchResponse,\n  WebSocketMessage,\n} from \"../types\";\nimport {\n  AlchemySendJsonRpcFunction,\n  AlchemySendJsonRpcResult,\n} from \"./alchemySend\";\n\ninterface RequestContext {\n  request: SingleOrBatchRequest;\n  resolve(response: AlchemySendJsonRpcResult): void;\n}\n\nexport function makeWebSocketSender(\n  ws: SturdyWebSocket,\n): AlchemySendJsonRpcFunction {\n  const contextsById = new Map<JsonRpcId, RequestContext>();\n  ws.addEventListener(\"message\", (message) => {\n    const response: WebSocketMessage = JSON.parse(message.data);\n    if (!isResponse(response)) {\n      return;\n    }\n    const id = getIdFromResponse(response);\n    if (id === undefined) {\n      return;\n    }\n    const context = contextsById.get(id);\n    if (!context) {\n      return;\n    }\n    const { resolve } = context;\n    contextsById.delete(id);\n    if (\n      !Array.isArray(response) &&\n      response.error &&\n      response.error.code === 429\n    ) {\n      resolve({ type: \"rateLimit\" });\n    } else {\n      resolve({ response, type: \"jsonrpc\" });\n    }\n  });\n  ws.addEventListener(\"down\", () => {\n    [...contextsById].forEach(([id, { request, resolve }]) => {\n      if (isWrite(request)) {\n        // Writes cannot be resent because they will fail for a duplicate nonce.\n        contextsById.delete(id);\n        resolve({\n          type: \"networkError\",\n          status: 0,\n          message: `WebSocket closed before receiving a response for write request with id: ${id}.`,\n        });\n      }\n    });\n  });\n  ws.addEventListener(\"reopen\", () => {\n    for (const { request } of contextsById.values()) {\n      ws.send(JSON.stringify(request));\n    }\n  });\n\n  return (request) =>\n    new Promise((resolve) => {\n      const id = getIdFromRequest(request);\n      if (id !== undefined) {\n        const existingContext = contextsById.get(id);\n        if (existingContext) {\n          const message = `Another WebSocket request was made with the same id (${id}) before a response was received.`;\n          console.error(message);\n          existingContext.resolve({\n            message,\n            type: \"networkError\",\n            status: 0,\n          });\n        }\n        contextsById.set(id, { request, resolve });\n      }\n      ws.send(JSON.stringify(request));\n    });\n}\n\nfunction getIdFromRequest(\n  request: SingleOrBatchRequest,\n): JsonRpcId | undefined {\n  if (!Array.isArray(request)) {\n    return request.id;\n  }\n  return getCanonicalIdFromList(request.map((p) => p.id));\n}\n\nfunction getIdFromResponse(\n  response: SingleOrBatchResponse,\n): JsonRpcId | undefined {\n  if (!Array.isArray(response)) {\n    return response.id;\n  }\n  return getCanonicalIdFromList(response.map((p) => p.id));\n}\n\n/**\n * Since the JSON-RPC spec allows responses to be returned in a different order\n * than sent, we need a mechanism for choosing a canonical id from a list that\n * doesn't depend on the order. This chooses the \"minimum\" id by an arbitrary\n * ordering: the smallest string if possible, otherwise the smallest number,\n * otherwise null.\n */\nfunction getCanonicalIdFromList(\n  ids: Array<JsonRpcId | undefined>,\n): JsonRpcId | undefined {\n  const stringIds: string[] = ids.filter((id) => typeof id === \"string\") as any;\n  if (stringIds.length > 0) {\n    return stringIds.reduce((bestId, id) => (bestId < id ? bestId : id));\n  }\n  const numberIds: number[] = ids.filter((id) => typeof id === \"number\") as any;\n  if (numberIds.length > 0) {\n    return Math.min(...numberIds);\n  }\n  return ids.indexOf(null) >= 0 ? null : undefined;\n}\n\nfunction isWrite(request: SingleOrBatchRequest): boolean {\n  return Array.isArray(request)\n    ? request.every(isSingleWrite)\n    : isSingleWrite(request);\n}\n\nconst WRITE_METHODS = [\"eth_sendTransaction\", \"eth_sendRawTransaction\"];\n\nfunction isSingleWrite(request: JsonRpcRequest): boolean {\n  return WRITE_METHODS.includes(request.method);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}