{"ast":null,"code":"const errors = {\n  IMPOSSIBLE_CASE: 'Impossible case. Please create issue.',\n  TWEAK_ADD: 'The tweak was out of range or the resulted private key is invalid',\n  TWEAK_MUL: 'The tweak was out of range or equal to zero',\n  CONTEXT_RANDOMIZE_UNKNOW: 'Unknow error on context randomization',\n  SECKEY_INVALID: 'Private Key is invalid',\n  PUBKEY_PARSE: 'Public Key could not be parsed',\n  PUBKEY_SERIALIZE: 'Public Key serialization error',\n  PUBKEY_COMBINE: 'The sum of the public keys is not valid',\n  SIG_PARSE: 'Signature could not be parsed',\n  SIGN: 'The nonce generation function failed, or the private key was invalid',\n  RECOVER: 'Public key could not be recover',\n  ECDH: 'Scalar was invalid (zero or overflow)'\n};\nfunction assert(cond, msg) {\n  if (!cond) throw new Error(msg);\n}\nfunction isUint8Array(name, value, length) {\n  assert(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`);\n  if (length !== undefined) {\n    if (Array.isArray(length)) {\n      const numbers = length.join(', ');\n      const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`;\n      assert(length.includes(value.length), msg);\n    } else {\n      const msg = `Expected ${name} to be an Uint8Array with length ${length}`;\n      assert(value.length === length, msg);\n    }\n  }\n}\nfunction isCompressed(value) {\n  assert(toTypeString(value) === 'Boolean', 'Expected compressed to be a Boolean');\n}\nfunction getAssertedOutput() {\n  let output = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : len => new Uint8Array(len);\n  let length = arguments.length > 1 ? arguments[1] : undefined;\n  if (typeof output === 'function') output = output(length);\n  isUint8Array('output', output, length);\n  return output;\n}\nfunction toTypeString(value) {\n  return Object.prototype.toString.call(value).slice(8, -1);\n}\nmodule.exports = secp256k1 => {\n  return {\n    contextRandomize(seed) {\n      assert(seed === null || seed instanceof Uint8Array, 'Expected seed to be an Uint8Array or null');\n      if (seed !== null) isUint8Array('seed', seed, 32);\n      switch (secp256k1.contextRandomize(seed)) {\n        case 1:\n          throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW);\n      }\n    },\n    privateKeyVerify(seckey) {\n      isUint8Array('private key', seckey, 32);\n      return secp256k1.privateKeyVerify(seckey) === 0;\n    },\n    privateKeyNegate(seckey) {\n      isUint8Array('private key', seckey, 32);\n      switch (secp256k1.privateKeyNegate(seckey)) {\n        case 0:\n          return seckey;\n        case 1:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n    privateKeyTweakAdd(seckey, tweak) {\n      isUint8Array('private key', seckey, 32);\n      isUint8Array('tweak', tweak, 32);\n      switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {\n        case 0:\n          return seckey;\n        case 1:\n          throw new Error(errors.TWEAK_ADD);\n      }\n    },\n    privateKeyTweakMul(seckey, tweak) {\n      isUint8Array('private key', seckey, 32);\n      isUint8Array('tweak', tweak, 32);\n      switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {\n        case 0:\n          return seckey;\n        case 1:\n          throw new Error(errors.TWEAK_MUL);\n      }\n    },\n    publicKeyVerify(pubkey) {\n      isUint8Array('public key', pubkey, [33, 65]);\n      return secp256k1.publicKeyVerify(pubkey) === 0;\n    },\n    publicKeyCreate(seckey) {\n      let compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      let output = arguments.length > 2 ? arguments[2] : undefined;\n      isUint8Array('private key', seckey, 32);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n      switch (secp256k1.publicKeyCreate(output, seckey)) {\n        case 0:\n          return output;\n        case 1:\n          throw new Error(errors.SECKEY_INVALID);\n        case 2:\n          throw new Error(errors.PUBKEY_SERIALIZE);\n      }\n    },\n    publicKeyConvert(pubkey) {\n      let compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      let output = arguments.length > 2 ? arguments[2] : undefined;\n      isUint8Array('public key', pubkey, [33, 65]);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n      switch (secp256k1.publicKeyConvert(output, pubkey)) {\n        case 0:\n          return output;\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n        case 2:\n          throw new Error(errors.PUBKEY_SERIALIZE);\n      }\n    },\n    publicKeyNegate(pubkey) {\n      let compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      let output = arguments.length > 2 ? arguments[2] : undefined;\n      isUint8Array('public key', pubkey, [33, 65]);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n      switch (secp256k1.publicKeyNegate(output, pubkey)) {\n        case 0:\n          return output;\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n        case 3:\n          throw new Error(errors.PUBKEY_SERIALIZE);\n      }\n    },\n    publicKeyCombine(pubkeys) {\n      let compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      let output = arguments.length > 2 ? arguments[2] : undefined;\n      assert(Array.isArray(pubkeys), 'Expected public keys to be an Array');\n      assert(pubkeys.length > 0, 'Expected public keys array will have more than zero items');\n      for (const pubkey of pubkeys) {\n        isUint8Array('public key', pubkey, [33, 65]);\n      }\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n      switch (secp256k1.publicKeyCombine(output, pubkeys)) {\n        case 0:\n          return output;\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n        case 2:\n          throw new Error(errors.PUBKEY_COMBINE);\n        case 3:\n          throw new Error(errors.PUBKEY_SERIALIZE);\n      }\n    },\n    publicKeyTweakAdd(pubkey, tweak) {\n      let compressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      let output = arguments.length > 3 ? arguments[3] : undefined;\n      isUint8Array('public key', pubkey, [33, 65]);\n      isUint8Array('tweak', tweak, 32);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n      switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {\n        case 0:\n          return output;\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n        case 2:\n          throw new Error(errors.TWEAK_ADD);\n      }\n    },\n    publicKeyTweakMul(pubkey, tweak) {\n      let compressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      let output = arguments.length > 3 ? arguments[3] : undefined;\n      isUint8Array('public key', pubkey, [33, 65]);\n      isUint8Array('tweak', tweak, 32);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n      switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {\n        case 0:\n          return output;\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n        case 2:\n          throw new Error(errors.TWEAK_MUL);\n      }\n    },\n    signatureNormalize(sig) {\n      isUint8Array('signature', sig, 64);\n      switch (secp256k1.signatureNormalize(sig)) {\n        case 0:\n          return sig;\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n      }\n    },\n    signatureExport(sig, output) {\n      isUint8Array('signature', sig, 64);\n      output = getAssertedOutput(output, 72);\n      const obj = {\n        output,\n        outputlen: 72\n      };\n      switch (secp256k1.signatureExport(obj, sig)) {\n        case 0:\n          return output.slice(0, obj.outputlen);\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n    signatureImport(sig, output) {\n      isUint8Array('signature', sig);\n      output = getAssertedOutput(output, 64);\n      switch (secp256k1.signatureImport(output, sig)) {\n        case 0:\n          return output;\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n    ecdsaSign(msg32, seckey) {\n      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      let output = arguments.length > 3 ? arguments[3] : undefined;\n      isUint8Array('message', msg32, 32);\n      isUint8Array('private key', seckey, 32);\n      assert(toTypeString(options) === 'Object', 'Expected options to be an Object');\n      if (options.data !== undefined) isUint8Array('options.data', options.data);\n      if (options.noncefn !== undefined) assert(toTypeString(options.noncefn) === 'Function', 'Expected options.noncefn to be a Function');\n      output = getAssertedOutput(output, 64);\n      const obj = {\n        signature: output,\n        recid: null\n      };\n      switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {\n        case 0:\n          return obj;\n        case 1:\n          throw new Error(errors.SIGN);\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n    ecdsaVerify(sig, msg32, pubkey) {\n      isUint8Array('signature', sig, 64);\n      isUint8Array('message', msg32, 32);\n      isUint8Array('public key', pubkey, [33, 65]);\n      switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {\n        case 0:\n          return true;\n        case 3:\n          return false;\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n        case 2:\n          throw new Error(errors.PUBKEY_PARSE);\n      }\n    },\n    ecdsaRecover(sig, recid, msg32) {\n      let compressed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      let output = arguments.length > 4 ? arguments[4] : undefined;\n      isUint8Array('signature', sig, 64);\n      assert(toTypeString(recid) === 'Number' && recid >= 0 && recid <= 3, 'Expected recovery id to be a Number within interval [0, 3]');\n      isUint8Array('message', msg32, 32);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n      switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {\n        case 0:\n          return output;\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n        case 2:\n          throw new Error(errors.RECOVER);\n        case 3:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n    ecdh(pubkey, seckey) {\n      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      let output = arguments.length > 3 ? arguments[3] : undefined;\n      isUint8Array('public key', pubkey, [33, 65]);\n      isUint8Array('private key', seckey, 32);\n      assert(toTypeString(options) === 'Object', 'Expected options to be an Object');\n      if (options.data !== undefined) isUint8Array('options.data', options.data);\n      if (options.hashfn !== undefined) {\n        assert(toTypeString(options.hashfn) === 'Function', 'Expected options.hashfn to be a Function');\n        if (options.xbuf !== undefined) isUint8Array('options.xbuf', options.xbuf, 32);\n        if (options.ybuf !== undefined) isUint8Array('options.ybuf', options.ybuf, 32);\n        isUint8Array('output', output);\n      } else {\n        output = getAssertedOutput(output, 32);\n      }\n      switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {\n        case 0:\n          return output;\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n        case 2:\n          throw new Error(errors.ECDH);\n      }\n    }\n  };\n};","map":{"version":3,"names":["errors","IMPOSSIBLE_CASE","TWEAK_ADD","TWEAK_MUL","CONTEXT_RANDOMIZE_UNKNOW","SECKEY_INVALID","PUBKEY_PARSE","PUBKEY_SERIALIZE","PUBKEY_COMBINE","SIG_PARSE","SIGN","RECOVER","ECDH","assert","cond","msg","Error","isUint8Array","name","value","length","Uint8Array","undefined","Array","isArray","numbers","join","includes","isCompressed","toTypeString","getAssertedOutput","output","arguments","len","Object","prototype","toString","call","slice","module","exports","secp256k1","contextRandomize","seed","privateKeyVerify","seckey","privateKeyNegate","privateKeyTweakAdd","tweak","privateKeyTweakMul","publicKeyVerify","pubkey","publicKeyCreate","compressed","publicKeyConvert","publicKeyNegate","publicKeyCombine","pubkeys","publicKeyTweakAdd","publicKeyTweakMul","signatureNormalize","sig","signatureExport","obj","outputlen","signatureImport","ecdsaSign","msg32","options","data","noncefn","signature","recid","ecdsaVerify","ecdsaRecover","ecdh","hashfn","xbuf","ybuf"],"sources":["C:/Users/jack/git/hackathon/starter-files/node_modules/secp256k1/lib/index.js"],"sourcesContent":["const errors = {\n  IMPOSSIBLE_CASE: 'Impossible case. Please create issue.',\n  TWEAK_ADD:\n    'The tweak was out of range or the resulted private key is invalid',\n  TWEAK_MUL: 'The tweak was out of range or equal to zero',\n  CONTEXT_RANDOMIZE_UNKNOW: 'Unknow error on context randomization',\n  SECKEY_INVALID: 'Private Key is invalid',\n  PUBKEY_PARSE: 'Public Key could not be parsed',\n  PUBKEY_SERIALIZE: 'Public Key serialization error',\n  PUBKEY_COMBINE: 'The sum of the public keys is not valid',\n  SIG_PARSE: 'Signature could not be parsed',\n  SIGN: 'The nonce generation function failed, or the private key was invalid',\n  RECOVER: 'Public key could not be recover',\n  ECDH: 'Scalar was invalid (zero or overflow)'\n}\n\nfunction assert (cond, msg) {\n  if (!cond) throw new Error(msg)\n}\n\nfunction isUint8Array (name, value, length) {\n  assert(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`)\n\n  if (length !== undefined) {\n    if (Array.isArray(length)) {\n      const numbers = length.join(', ')\n      const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`\n      assert(length.includes(value.length), msg)\n    } else {\n      const msg = `Expected ${name} to be an Uint8Array with length ${length}`\n      assert(value.length === length, msg)\n    }\n  }\n}\n\nfunction isCompressed (value) {\n  assert(toTypeString(value) === 'Boolean', 'Expected compressed to be a Boolean')\n}\n\nfunction getAssertedOutput (output = (len) => new Uint8Array(len), length) {\n  if (typeof output === 'function') output = output(length)\n  isUint8Array('output', output, length)\n  return output\n}\n\nfunction toTypeString (value) {\n  return Object.prototype.toString.call(value).slice(8, -1)\n}\n\nmodule.exports = (secp256k1) => {\n  return {\n    contextRandomize (seed) {\n      assert(\n        seed === null || seed instanceof Uint8Array,\n        'Expected seed to be an Uint8Array or null'\n      )\n      if (seed !== null) isUint8Array('seed', seed, 32)\n\n      switch (secp256k1.contextRandomize(seed)) {\n        case 1:\n          throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW)\n      }\n    },\n\n    privateKeyVerify (seckey) {\n      isUint8Array('private key', seckey, 32)\n\n      return secp256k1.privateKeyVerify(seckey) === 0\n    },\n\n    privateKeyNegate (seckey) {\n      isUint8Array('private key', seckey, 32)\n\n      switch (secp256k1.privateKeyNegate(seckey)) {\n        case 0:\n          return seckey\n        case 1:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    privateKeyTweakAdd (seckey, tweak) {\n      isUint8Array('private key', seckey, 32)\n      isUint8Array('tweak', tweak, 32)\n\n      switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {\n        case 0:\n          return seckey\n        case 1:\n          throw new Error(errors.TWEAK_ADD)\n      }\n    },\n\n    privateKeyTweakMul (seckey, tweak) {\n      isUint8Array('private key', seckey, 32)\n      isUint8Array('tweak', tweak, 32)\n\n      switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {\n        case 0:\n          return seckey\n        case 1:\n          throw new Error(errors.TWEAK_MUL)\n      }\n    },\n\n    publicKeyVerify (pubkey) {\n      isUint8Array('public key', pubkey, [33, 65])\n\n      return secp256k1.publicKeyVerify(pubkey) === 0\n    },\n\n    publicKeyCreate (seckey, compressed = true, output) {\n      isUint8Array('private key', seckey, 32)\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyCreate(output, seckey)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.SECKEY_INVALID)\n        case 2:\n          throw new Error(errors.PUBKEY_SERIALIZE)\n      }\n    },\n\n    publicKeyConvert (pubkey, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyConvert(output, pubkey)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.PUBKEY_SERIALIZE)\n      }\n    },\n\n    publicKeyNegate (pubkey, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyNegate(output, pubkey)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n        case 3:\n          throw new Error(errors.PUBKEY_SERIALIZE)\n      }\n    },\n\n    publicKeyCombine (pubkeys, compressed = true, output) {\n      assert(Array.isArray(pubkeys), 'Expected public keys to be an Array')\n      assert(pubkeys.length > 0, 'Expected public keys array will have more than zero items')\n      for (const pubkey of pubkeys) {\n        isUint8Array('public key', pubkey, [33, 65])\n      }\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyCombine(output, pubkeys)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.PUBKEY_COMBINE)\n        case 3:\n          throw new Error(errors.PUBKEY_SERIALIZE)\n      }\n    },\n\n    publicKeyTweakAdd (pubkey, tweak, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isUint8Array('tweak', tweak, 32)\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.TWEAK_ADD)\n      }\n    },\n\n    publicKeyTweakMul (pubkey, tweak, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isUint8Array('tweak', tweak, 32)\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.TWEAK_MUL)\n      }\n    },\n\n    signatureNormalize (sig) {\n      isUint8Array('signature', sig, 64)\n\n      switch (secp256k1.signatureNormalize(sig)) {\n        case 0:\n          return sig\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n      }\n    },\n\n    signatureExport (sig, output) {\n      isUint8Array('signature', sig, 64)\n      output = getAssertedOutput(output, 72)\n\n      const obj = { output, outputlen: 72 }\n      switch (secp256k1.signatureExport(obj, sig)) {\n        case 0:\n          return output.slice(0, obj.outputlen)\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    signatureImport (sig, output) {\n      isUint8Array('signature', sig)\n      output = getAssertedOutput(output, 64)\n\n      switch (secp256k1.signatureImport(output, sig)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    ecdsaSign (msg32, seckey, options = {}, output) {\n      isUint8Array('message', msg32, 32)\n      isUint8Array('private key', seckey, 32)\n      assert(toTypeString(options) === 'Object', 'Expected options to be an Object')\n      if (options.data !== undefined) isUint8Array('options.data', options.data)\n      if (options.noncefn !== undefined) assert(toTypeString(options.noncefn) === 'Function', 'Expected options.noncefn to be a Function')\n      output = getAssertedOutput(output, 64)\n\n      const obj = { signature: output, recid: null }\n      switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {\n        case 0:\n          return obj\n        case 1:\n          throw new Error(errors.SIGN)\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    ecdsaVerify (sig, msg32, pubkey) {\n      isUint8Array('signature', sig, 64)\n      isUint8Array('message', msg32, 32)\n      isUint8Array('public key', pubkey, [33, 65])\n\n      switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {\n        case 0:\n          return true\n        case 3:\n          return false\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n        case 2:\n          throw new Error(errors.PUBKEY_PARSE)\n      }\n    },\n\n    ecdsaRecover (sig, recid, msg32, compressed = true, output) {\n      isUint8Array('signature', sig, 64)\n      assert(\n        toTypeString(recid) === 'Number' &&\n          recid >= 0 &&\n          recid <= 3,\n        'Expected recovery id to be a Number within interval [0, 3]'\n      )\n      isUint8Array('message', msg32, 32)\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n        case 2:\n          throw new Error(errors.RECOVER)\n        case 3:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    ecdh (pubkey, seckey, options = {}, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isUint8Array('private key', seckey, 32)\n      assert(toTypeString(options) === 'Object', 'Expected options to be an Object')\n      if (options.data !== undefined) isUint8Array('options.data', options.data)\n      if (options.hashfn !== undefined) {\n        assert(toTypeString(options.hashfn) === 'Function', 'Expected options.hashfn to be a Function')\n        if (options.xbuf !== undefined) isUint8Array('options.xbuf', options.xbuf, 32)\n        if (options.ybuf !== undefined) isUint8Array('options.ybuf', options.ybuf, 32)\n        isUint8Array('output', output)\n      } else {\n        output = getAssertedOutput(output, 32)\n      }\n\n      switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.ECDH)\n      }\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}