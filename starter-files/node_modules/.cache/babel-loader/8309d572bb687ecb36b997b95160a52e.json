{"ast":null,"code":"import { __assign, __awaiter, __extends, __generator, __read, __spreadArray, __values } from \"tslib\";\nimport EventEmitter from \"eventemitter3\";\nimport { dedupeLogs, dedupeNewHeads, makeBackfiller } from \"../subscriptions/subscriptionBackfill\";\nimport { isSubscriptionEvent } from \"../types\";\nimport { fromHex } from \"../util/hex\";\nimport { makeResponse } from \"../util/jsonRpc\";\nimport { callWhenDone, makeCancelToken, throwIfCancelled, withBackoffRetries, withTimeout } from \"../util/promises\";\nvar HEARTBEAT_INTERVAL = 30000;\nvar HEARTBEAT_WAIT_TIME = 10000;\nvar BACKFILL_TIMEOUT = 60000;\nvar BACKFILL_RETRIES = 5;\n/**\n * Subscriptions have a memory of recent events they have sent so that in the\n * event that they disconnect and need to backfill, they can detect re-orgs.\n * Keep a buffer that goes back at least these many blocks, the maximum amount\n * at which we might conceivably see a re-org.\n *\n * Note that while our buffer goes back this many blocks, it may contain more\n * than this many elements, since in the case of logs subscriptions more than\n * one event may be emitted for a block.\n */\nvar RETAINED_EVENT_BLOCK_COUNT = 10;\nvar AlchemyWebSocketProvider = /** @class */function (_super) {\n  __extends(AlchemyWebSocketProvider, _super);\n  function AlchemyWebSocketProvider(ws, sendJsonRpcPayload, jsonRpcSenders) {\n    var _this = _super.call(this) || this;\n    _this.ws = ws;\n    _this.sendJsonRpcPayload = sendJsonRpcPayload;\n    _this.jsonRpcSenders = jsonRpcSenders;\n    // In the case of a WebSocket reconnection, all subscriptions are lost and we\n    // create new ones to replace them, but we want to create the illusion that\n    // the original subscriptions persist. Thus, maintain a mapping from the\n    // \"virtual\" subscription ids which are visible to the consumer to the\n    // \"physical\" subscription ids of the actual connections. This terminology is\n    // borrowed from virtual and physical memory, which has a similar mapping.\n    _this.virtualSubscriptionsById = new Map();\n    _this.virtualIdsByPhysicalId = new Map();\n    _this.cancelBackfill = noop;\n    _this.startHeartbeat = function () {\n      if (_this.heartbeatIntervalId != null) {\n        return;\n      }\n      _this.heartbeatIntervalId = setInterval(function () {\n        return __awaiter(_this, void 0, void 0, function () {\n          var _a;\n          return __generator(this, function (_b) {\n            switch (_b.label) {\n              case 0:\n                _b.trys.push([0, 2,, 3]);\n                return [4 /*yield*/, withTimeout(this.jsonRpcSenders.send(\"net_version\"), HEARTBEAT_WAIT_TIME)];\n              case 1:\n                _b.sent();\n                return [3 /*break*/, 3];\n              case 2:\n                _a = _b.sent();\n                this.ws.reconnect();\n                return [3 /*break*/, 3];\n              case 3:\n                return [2 /*return*/];\n            }\n          });\n        });\n      }, HEARTBEAT_INTERVAL);\n    };\n    _this.stopHeartbeatAndBackfill = function () {\n      if (_this.heartbeatIntervalId != null) {\n        clearInterval(_this.heartbeatIntervalId);\n        _this.heartbeatIntervalId = undefined;\n      }\n      _this.cancelBackfill();\n    };\n    _this.handleMessage = function (event) {\n      var message = JSON.parse(event.data);\n      if (!isSubscriptionEvent(message)) {\n        return;\n      }\n      var physicalId = message.params.subscription;\n      var virtualId = _this.virtualIdsByPhysicalId.get(physicalId);\n      if (!virtualId) {\n        return;\n      }\n      var subscription = _this.virtualSubscriptionsById.get(virtualId);\n      if (subscription.method !== \"eth_subscribe\") {\n        _this.emitGenericEvent(virtualId, message.params.result);\n        return;\n      }\n      switch (subscription.params[0]) {\n        case \"newHeads\":\n          {\n            var newHeadsSubscription = subscription;\n            var newHeadsMessage = message;\n            var isBackfilling = newHeadsSubscription.isBackfilling,\n              backfillBuffer = newHeadsSubscription.backfillBuffer;\n            var result = newHeadsMessage.params.result;\n            if (isBackfilling) {\n              addToNewHeadsEventsBuffer(backfillBuffer, result);\n            } else {\n              _this.emitNewHeadsEvent(virtualId, result);\n            }\n            break;\n          }\n        case \"logs\":\n          {\n            var logsSubscription = subscription;\n            var logsMessage = message;\n            var isBackfilling = logsSubscription.isBackfilling,\n              backfillBuffer = logsSubscription.backfillBuffer;\n            var result = logsMessage.params.result;\n            if (isBackfilling) {\n              addToLogsEventsBuffer(backfillBuffer, result);\n            } else {\n              _this.emitLogsEvent(virtualId, result);\n            }\n            break;\n          }\n        default:\n          _this.emitGenericEvent(virtualId, message.params.result);\n      }\n    };\n    _this.handleReopen = function () {\n      var e_1, _a;\n      _this.virtualIdsByPhysicalId.clear();\n      var _b = makeCancelToken(),\n        cancel = _b.cancel,\n        isCancelled = _b.isCancelled;\n      _this.cancelBackfill = cancel;\n      var _loop_1 = function (subscription) {\n        (function () {\n          return __awaiter(_this, void 0, void 0, function () {\n            var error_1;\n            return __generator(this, function (_a) {\n              switch (_a.label) {\n                case 0:\n                  _a.trys.push([0, 2,, 3]);\n                  return [4 /*yield*/, this.resubscribeAndBackfill(isCancelled, subscription)];\n                case 1:\n                  _a.sent();\n                  return [3 /*break*/, 3];\n                case 2:\n                  error_1 = _a.sent();\n                  if (!isCancelled()) {\n                    console.error(\"Error while backfilling \\\"\" + subscription.params[0] + \"\\\" subscription. Some events may be missing.\", error_1);\n                  }\n                  return [3 /*break*/, 3];\n                case 3:\n                  return [2 /*return*/];\n              }\n            });\n          });\n        })();\n      };\n\n      try {\n        for (var _c = __values(_this.virtualSubscriptionsById.values()), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var subscription = _d.value;\n          _loop_1(subscription);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n      _this.startHeartbeat();\n    };\n    _this.backfiller = makeBackfiller(jsonRpcSenders);\n    _this.addSocketListeners();\n    _this.startHeartbeat();\n    return _this;\n  }\n  AlchemyWebSocketProvider.prototype.send = function (request, callback) {\n    if (isSubscribeRequest(request)) {\n      var id = request.id;\n      if (id === undefined) {\n        // The JSON-RPC spec says to return nothing if there is no request id.\n        return;\n      }\n      callWhenDone(this.subscribe(request), callback);\n      return;\n    }\n    if (isUnsubscribeRequest(request)) {\n      callWhenDone(this.unsubscribe(request), callback);\n      return;\n    }\n    callWhenDone(this.sendJsonRpcPayload(request), callback);\n  };\n  AlchemyWebSocketProvider.prototype.supportsSubscriptions = function () {\n    return true;\n  };\n  AlchemyWebSocketProvider.prototype.disconnect = function (code, reason) {\n    this.removeSocketListeners();\n    this.removeAllListeners();\n    this.stopHeartbeatAndBackfill();\n    this.ws.close(code, reason);\n  };\n  AlchemyWebSocketProvider.prototype.connect = function () {\n    // No-op. We're already connected when passed a websocket in the\n    // constructor.\n  };\n  AlchemyWebSocketProvider.prototype.reset = function () {\n    // No-op.\n  };\n  AlchemyWebSocketProvider.prototype.reconnect = function () {\n    // No-op. This isn't called anywhere.\n  };\n  AlchemyWebSocketProvider.prototype.subscribe = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var method, _a, params, startingBlockNumber, response, id;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            method = request.method, _a = request.params, params = _a === void 0 ? [] : _a;\n            return [4 /*yield*/, this.getBlockNumber()];\n          case 1:\n            startingBlockNumber = _b.sent();\n            return [4 /*yield*/, this.sendJsonRpcPayload(request)];\n          case 2:\n            response = _b.sent();\n            id = response.result;\n            this.virtualSubscriptionsById.set(id, {\n              method: method,\n              params: params,\n              startingBlockNumber: startingBlockNumber,\n              virtualId: id,\n              physicalId: id,\n              sentEvents: [],\n              isBackfilling: false,\n              backfillBuffer: []\n            });\n            this.virtualIdsByPhysicalId.set(id, id);\n            return [2 /*return*/, makeResponse(request.id, id)];\n        }\n      });\n    });\n  };\n  AlchemyWebSocketProvider.prototype.unsubscribe = function (request) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function () {\n      var subscriptionId, virtualSubscription, physicalId, physicalRequest;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            subscriptionId = (_a = request.params) === null || _a === void 0 ? void 0 : _a[0];\n            virtualSubscription = this.virtualSubscriptionsById.get(subscriptionId);\n            if (!virtualSubscription) {\n              return [2 /*return*/, makeResponse(request.id, false)];\n            }\n            physicalId = virtualSubscription.physicalId;\n            physicalRequest = __assign(__assign({}, request), {\n              params: [physicalId]\n            });\n            return [4 /*yield*/, this.sendJsonRpcPayload(physicalRequest)];\n          case 1:\n            _b.sent();\n            this.virtualSubscriptionsById.delete(subscriptionId);\n            this.virtualIdsByPhysicalId.delete(physicalId);\n            return [2 /*return*/, makeResponse(request.id, true)];\n        }\n      });\n    });\n  };\n  AlchemyWebSocketProvider.prototype.addSocketListeners = function () {\n    this.ws.addEventListener(\"message\", this.handleMessage);\n    this.ws.addEventListener(\"reopen\", this.handleReopen);\n    this.ws.addEventListener(\"down\", this.stopHeartbeatAndBackfill);\n  };\n  AlchemyWebSocketProvider.prototype.removeSocketListeners = function () {\n    this.ws.removeEventListener(\"message\", this.handleMessage);\n    this.ws.removeEventListener(\"reopen\", this.handleReopen);\n    this.ws.removeEventListener(\"down\", this.stopHeartbeatAndBackfill);\n  };\n  AlchemyWebSocketProvider.prototype.resubscribeAndBackfill = function (isCancelled, subscription) {\n    return __awaiter(this, void 0, void 0, function () {\n      var virtualId, method, params, sentEvents, backfillBuffer, startingBlockNumber, physicalId, _a, backfillEvents, events, filter_1, backfillEvents, events;\n      var _this = this;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            virtualId = subscription.virtualId, method = subscription.method, params = subscription.params, sentEvents = subscription.sentEvents, backfillBuffer = subscription.backfillBuffer, startingBlockNumber = subscription.startingBlockNumber;\n            subscription.isBackfilling = true;\n            backfillBuffer.length = 0;\n            _b.label = 1;\n          case 1:\n            _b.trys.push([1,, 9, 10]);\n            return [4 /*yield*/, this.jsonRpcSenders.send(method, params)];\n          case 2:\n            physicalId = _b.sent();\n            throwIfCancelled(isCancelled);\n            subscription.physicalId = physicalId;\n            this.virtualIdsByPhysicalId.set(physicalId, virtualId);\n            _a = params[0];\n            switch (_a) {\n              case \"newHeads\":\n                return [3 /*break*/, 3];\n              case \"logs\":\n                return [3 /*break*/, 5];\n            }\n            return [3 /*break*/, 7];\n          case 3:\n            return [4 /*yield*/, withBackoffRetries(function () {\n              return withTimeout(_this.backfiller.getNewHeadsBackfill(isCancelled, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT);\n            }, BACKFILL_RETRIES, function () {\n              return !isCancelled();\n            })];\n          case 4:\n            backfillEvents = _b.sent();\n            throwIfCancelled(isCancelled);\n            events = dedupeNewHeads(__spreadArray(__spreadArray([], __read(backfillEvents)), __read(backfillBuffer)));\n            events.forEach(function (event) {\n              return _this.emitNewHeadsEvent(virtualId, event);\n            });\n            return [3 /*break*/, 8];\n          case 5:\n            filter_1 = params[1] || {};\n            return [4 /*yield*/, withBackoffRetries(function () {\n              return withTimeout(_this.backfiller.getLogsBackfill(isCancelled, filter_1, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT);\n            }, BACKFILL_RETRIES, function () {\n              return !isCancelled();\n            })];\n          case 6:\n            backfillEvents = _b.sent();\n            throwIfCancelled(isCancelled);\n            events = dedupeLogs(__spreadArray(__spreadArray([], __read(backfillEvents)), __read(backfillBuffer)));\n            events.forEach(function (event) {\n              return _this.emitLogsEvent(virtualId, event);\n            });\n            return [3 /*break*/, 8];\n          case 7:\n            return [3 /*break*/, 8];\n          case 8:\n            return [3 /*break*/, 10];\n          case 9:\n            subscription.isBackfilling = false;\n            backfillBuffer.length = 0;\n            return [7 /*endfinally*/];\n          case 10:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  AlchemyWebSocketProvider.prototype.getBlockNumber = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var blockNumberHex;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.jsonRpcSenders.send(\"eth_blockNumber\")];\n          case 1:\n            blockNumberHex = _a.sent();\n            return [2 /*return*/, fromHex(blockNumberHex)];\n        }\n      });\n    });\n  };\n  AlchemyWebSocketProvider.prototype.emitNewHeadsEvent = function (virtualId, result) {\n    this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n  };\n  AlchemyWebSocketProvider.prototype.emitLogsEvent = function (virtualId, result) {\n    this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n  };\n  /**\n   * Emits an event to consumers, but also remembers it in its subscriptions's\n   * `sentEvents` buffer so that we can detect re-orgs if the connection drops\n   * and needs to be reconnected.\n   */\n  AlchemyWebSocketProvider.prototype.emitAndRememberEvent = function (virtualId, result, getBlockNumber) {\n    var subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    // Web3 modifies these event objects once we pass them on (changing hex\n    // numbers to numbers). We want the original event, so make a defensive\n    // copy.\n    addToPastEventsBuffer(subscription.sentEvents, __assign({}, result), getBlockNumber);\n    this.emitGenericEvent(virtualId, result);\n  };\n  AlchemyWebSocketProvider.prototype.emitGenericEvent = function (virtualId, result) {\n    var event = {\n      jsonrpc: \"2.0\",\n      method: \"eth_subscription\",\n      params: {\n        subscription: virtualId,\n        result: result\n      }\n    };\n    this.emit(\"data\", event);\n  };\n  return AlchemyWebSocketProvider;\n}(EventEmitter);\nexport { AlchemyWebSocketProvider };\nfunction addToNewHeadsEventsBuffer(pastEvents, event) {\n  addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\n}\nfunction addToLogsEventsBuffer(pastEvents, event) {\n  addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\n}\n/**\n * Adds a new event to an array of events, evicting any events which\n * are so old that they will no longer feasibly be part of a reorg.\n */\nfunction addToPastEventsBuffer(pastEvents, event, getBlockNumber) {\n  var currentBlockNumber = getBlockNumber(event);\n  // Find first index of an event recent enough to retain, then drop everything\n  // at a lower index.\n  var firstGoodIndex = pastEvents.findIndex(function (e) {\n    return getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT;\n  });\n  if (firstGoodIndex === -1) {\n    pastEvents.length = 0;\n  } else {\n    pastEvents.splice(0, firstGoodIndex);\n  }\n  pastEvents.push(event);\n}\nfunction isSubscribeRequest(request) {\n  return !Array.isArray(request) && request.method === \"eth_subscribe\";\n}\nfunction isUnsubscribeRequest(request) {\n  return !Array.isArray(request) && request.method === \"eth_unsubscribe\";\n}\nfunction getNewHeadsBlockNumber(event) {\n  return fromHex(event.number);\n}\nfunction getLogsBlockNumber(event) {\n  return fromHex(event.blockNumber);\n}\nfunction noop() {\n  // Nothing.\n}","map":{"version":3,"names":["EventEmitter","dedupeLogs","dedupeNewHeads","makeBackfiller","isSubscriptionEvent","fromHex","makeResponse","callWhenDone","makeCancelToken","throwIfCancelled","withBackoffRetries","withTimeout","HEARTBEAT_INTERVAL","HEARTBEAT_WAIT_TIME","BACKFILL_TIMEOUT","BACKFILL_RETRIES","RETAINED_EVENT_BLOCK_COUNT","AlchemyWebSocketProvider","_super","__extends","ws","sendJsonRpcPayload","jsonRpcSenders","_this","call","virtualSubscriptionsById","Map","virtualIdsByPhysicalId","cancelBackfill","noop","startHeartbeat","heartbeatIntervalId","setInterval","__awaiter","send","_b","sent","reconnect","stopHeartbeatAndBackfill","clearInterval","undefined","handleMessage","event","message","JSON","parse","data","physicalId","params","subscription","virtualId","get","method","emitGenericEvent","result","newHeadsSubscription","newHeadsMessage","isBackfilling","backfillBuffer","addToNewHeadsEventsBuffer","emitNewHeadsEvent","logsSubscription","logsMessage","addToLogsEventsBuffer","emitLogsEvent","handleReopen","clear","cancel","isCancelled","resubscribeAndBackfill","_a","console","error","error_1","_c","__values","values","_d","next","done","value","backfiller","addSocketListeners","prototype","request","callback","isSubscribeRequest","id","subscribe","isUnsubscribeRequest","unsubscribe","supportsSubscriptions","disconnect","code","reason","removeSocketListeners","removeAllListeners","close","connect","reset","getBlockNumber","startingBlockNumber","response","set","sentEvents","subscriptionId","virtualSubscription","physicalRequest","__assign","delete","addEventListener","removeEventListener","length","getNewHeadsBackfill","backfillEvents","events","__spreadArray","__read","forEach","filter_1","getLogsBackfill","blockNumberHex","emitAndRememberEvent","getNewHeadsBlockNumber","getLogsBlockNumber","addToPastEventsBuffer","jsonrpc","emit","pastEvents","currentBlockNumber","firstGoodIndex","findIndex","e","splice","push","Array","isArray","number","blockNumber"],"sources":["../../../src/web3-adapter/webSocketProvider.ts"],"sourcesContent":["import EventEmitter from \"eventemitter3\";\nimport SturdyWebSocket from \"sturdy-websocket\";\nimport {\n  Backfiller,\n  dedupeLogs,\n  dedupeNewHeads,\n  LogsEvent,\n  LogsSubscriptionFilter,\n  makeBackfiller,\n  NewHeadsEvent,\n} from \"../subscriptions/subscriptionBackfill\";\nimport {\n  isSubscriptionEvent,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  SingleOrBatchRequest,\n  SingleOrBatchResponse,\n  SubscriptionEvent,\n  WebSocketMessage,\n} from \"../types\";\nimport { fromHex } from \"../util/hex\";\nimport { JsonRpcSenders, makeResponse } from \"../util/jsonRpc\";\nimport {\n  callWhenDone,\n  makeCancelToken,\n  throwIfCancelled,\n  withBackoffRetries,\n  withTimeout,\n} from \"../util/promises\";\nimport { SendJsonRpcPayloadFunction } from \"./sendJsonRpcPayload\";\n\nconst HEARTBEAT_INTERVAL = 30000;\nconst HEARTBEAT_WAIT_TIME = 10000;\nconst BACKFILL_TIMEOUT = 60000;\nconst BACKFILL_RETRIES = 5;\n/**\n * Subscriptions have a memory of recent events they have sent so that in the\n * event that they disconnect and need to backfill, they can detect re-orgs.\n * Keep a buffer that goes back at least these many blocks, the maximum amount\n * at which we might conceivably see a re-org.\n *\n * Note that while our buffer goes back this many blocks, it may contain more\n * than this many elements, since in the case of logs subscriptions more than\n * one event may be emitted for a block.\n */\nconst RETAINED_EVENT_BLOCK_COUNT = 10;\n\n/**\n * This is the undocumented interface required by Web3 for providers which\n * handle subscriptions.\n *\n * In addition to the stated methods here, it communicates subscription events\n * by using `EventEmitter#emit(\"data\", event)` to emit the events.\n */\nexport interface Web3SubscriptionProvider extends EventEmitter {\n  send(\n    payload: SingleOrBatchRequest,\n    callback: (error: any, response?: SingleOrBatchResponse) => void,\n  ): void;\n  disconnect(code?: number, reason?: string): void;\n  supportsSubscriptions(): true;\n  connect(): void;\n  reset(): void;\n  reconnect(): void;\n}\n\ninterface VirtualSubscription {\n  virtualId: string;\n  physicalId: string;\n  method: string;\n  params: any[];\n  isBackfilling: boolean;\n  startingBlockNumber: number;\n  sentEvents: any[];\n  backfillBuffer: any[];\n}\n\ninterface NewHeadsSubscription extends VirtualSubscription {\n  method: \"eth_subscribe\";\n  params: [\"newHeads\"];\n  isBackfilling: boolean;\n  sentEvents: NewHeadsEvent[];\n  backfillBuffer: NewHeadsEvent[];\n}\n\ninterface LogsSubscription extends VirtualSubscription {\n  method: \"eth_subscribe\";\n  params: [\"logs\", LogsSubscriptionFilter?];\n  isBackfilling: boolean;\n  sentEvents: LogsEvent[];\n  backfillBuffer: LogsEvent[];\n}\n\nexport class AlchemyWebSocketProvider\n  extends EventEmitter\n  implements Web3SubscriptionProvider\n{\n  // In the case of a WebSocket reconnection, all subscriptions are lost and we\n  // create new ones to replace them, but we want to create the illusion that\n  // the original subscriptions persist. Thus, maintain a mapping from the\n  // \"virtual\" subscription ids which are visible to the consumer to the\n  // \"physical\" subscription ids of the actual connections. This terminology is\n  // borrowed from virtual and physical memory, which has a similar mapping.\n  private readonly virtualSubscriptionsById: Map<string, VirtualSubscription> =\n    new Map();\n  private readonly virtualIdsByPhysicalId: Map<string, string> = new Map();\n  private readonly backfiller: Backfiller;\n  private heartbeatIntervalId?: NodeJS.Timeout;\n  private cancelBackfill = noop;\n\n  constructor(\n    private readonly ws: SturdyWebSocket,\n    private readonly sendJsonRpcPayload: SendJsonRpcPayloadFunction,\n    private readonly jsonRpcSenders: JsonRpcSenders,\n  ) {\n    super();\n    this.backfiller = makeBackfiller(jsonRpcSenders);\n    this.addSocketListeners();\n    this.startHeartbeat();\n  }\n\n  public send(\n    request: SingleOrBatchRequest,\n    callback: (error: any, response?: SingleOrBatchResponse) => void,\n  ): void {\n    if (isSubscribeRequest(request)) {\n      const { id } = request;\n      if (id === undefined) {\n        // The JSON-RPC spec says to return nothing if there is no request id.\n        return;\n      }\n      callWhenDone(this.subscribe(request), callback);\n      return;\n    }\n    if (isUnsubscribeRequest(request)) {\n      callWhenDone(this.unsubscribe(request), callback);\n      return;\n    }\n    callWhenDone(this.sendJsonRpcPayload(request), callback);\n  }\n\n  public supportsSubscriptions(): true {\n    return true;\n  }\n\n  public disconnect(code?: number, reason?: string): void {\n    this.removeSocketListeners();\n    this.removeAllListeners();\n    this.stopHeartbeatAndBackfill();\n    this.ws.close(code, reason);\n  }\n\n  public connect(): void {\n    // No-op. We're already connected when passed a websocket in the\n    // constructor.\n  }\n\n  public reset(): void {\n    // No-op.\n  }\n\n  public reconnect(): void {\n    // No-op. This isn't called anywhere.\n  }\n\n  private async subscribe(request: JsonRpcRequest): Promise<JsonRpcResponse> {\n    const { method, params = [] } = request;\n    const startingBlockNumber = await this.getBlockNumber();\n    const response = await this.sendJsonRpcPayload(request);\n    const id = response.result;\n    this.virtualSubscriptionsById.set(id, {\n      method,\n      params,\n      startingBlockNumber,\n      virtualId: id,\n      physicalId: id,\n      sentEvents: [],\n      isBackfilling: false,\n      backfillBuffer: [],\n    });\n    this.virtualIdsByPhysicalId.set(id, id);\n    return makeResponse(request.id!, id);\n  }\n\n  private async unsubscribe(request: JsonRpcRequest): Promise<JsonRpcResponse> {\n    const subscriptionId = request.params?.[0];\n    const virtualSubscription =\n      this.virtualSubscriptionsById.get(subscriptionId);\n    if (!virtualSubscription) {\n      return makeResponse(request.id!, false);\n    }\n    const { physicalId } = virtualSubscription;\n    const physicalRequest = { ...request, params: [physicalId] };\n    await this.sendJsonRpcPayload(physicalRequest);\n    this.virtualSubscriptionsById.delete(subscriptionId);\n    this.virtualIdsByPhysicalId.delete(physicalId);\n    return makeResponse(request.id!, true);\n  }\n\n  private addSocketListeners(): void {\n    this.ws.addEventListener(\"message\", this.handleMessage);\n    this.ws.addEventListener(\"reopen\", this.handleReopen);\n    this.ws.addEventListener(\"down\", this.stopHeartbeatAndBackfill);\n  }\n\n  private removeSocketListeners(): void {\n    this.ws.removeEventListener(\"message\", this.handleMessage);\n    this.ws.removeEventListener(\"reopen\", this.handleReopen);\n    this.ws.removeEventListener(\"down\", this.stopHeartbeatAndBackfill);\n  }\n\n  private startHeartbeat = (): void => {\n    if (this.heartbeatIntervalId != null) {\n      return;\n    }\n    this.heartbeatIntervalId = setInterval(async () => {\n      try {\n        await withTimeout(\n          this.jsonRpcSenders.send(\"net_version\"),\n          HEARTBEAT_WAIT_TIME,\n        );\n      } catch {\n        this.ws.reconnect();\n      }\n    }, HEARTBEAT_INTERVAL);\n  };\n\n  private stopHeartbeatAndBackfill = (): void => {\n    if (this.heartbeatIntervalId != null) {\n      clearInterval(this.heartbeatIntervalId);\n      this.heartbeatIntervalId = undefined;\n    }\n    this.cancelBackfill();\n  };\n\n  private handleMessage = (event: MessageEvent): void => {\n    const message: WebSocketMessage = JSON.parse(event.data);\n    if (!isSubscriptionEvent(message)) {\n      return;\n    }\n    const physicalId = message.params.subscription;\n    const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\n    if (!virtualId) {\n      return;\n    }\n    const subscription = this.virtualSubscriptionsById.get(virtualId)!;\n    if (subscription.method !== \"eth_subscribe\") {\n      this.emitGenericEvent(virtualId, message.params.result);\n      return;\n    }\n    switch (subscription.params[0]) {\n      case \"newHeads\": {\n        const newHeadsSubscription = subscription as NewHeadsSubscription;\n        const newHeadsMessage = message as SubscriptionEvent<NewHeadsEvent>;\n        const { isBackfilling, backfillBuffer } = newHeadsSubscription;\n        const { result } = newHeadsMessage.params;\n        if (isBackfilling) {\n          addToNewHeadsEventsBuffer(backfillBuffer, result);\n        } else {\n          this.emitNewHeadsEvent(virtualId, result);\n        }\n        break;\n      }\n      case \"logs\": {\n        const logsSubscription = subscription as LogsSubscription;\n        const logsMessage = message as SubscriptionEvent<LogsEvent>;\n        const { isBackfilling, backfillBuffer } = logsSubscription;\n        const { result } = logsMessage.params;\n        if (isBackfilling) {\n          addToLogsEventsBuffer(backfillBuffer, result);\n        } else {\n          this.emitLogsEvent(virtualId, result);\n        }\n        break;\n      }\n      default:\n        this.emitGenericEvent(virtualId, message.params.result);\n    }\n  };\n\n  private handleReopen = (): void => {\n    this.virtualIdsByPhysicalId.clear();\n    const { cancel, isCancelled } = makeCancelToken();\n    this.cancelBackfill = cancel;\n    for (const subscription of this.virtualSubscriptionsById.values()) {\n      (async () => {\n        try {\n          await this.resubscribeAndBackfill(isCancelled, subscription);\n        } catch (error) {\n          if (!isCancelled()) {\n            console.error(\n              `Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`,\n              error,\n            );\n          }\n        }\n      })();\n    }\n    this.startHeartbeat();\n  };\n\n  private async resubscribeAndBackfill(\n    isCancelled: () => boolean,\n    subscription: VirtualSubscription,\n  ): Promise<void> {\n    const {\n      virtualId,\n      method,\n      params,\n      sentEvents,\n      backfillBuffer,\n      startingBlockNumber,\n    } = subscription;\n    subscription.isBackfilling = true;\n    backfillBuffer.length = 0;\n    try {\n      const physicalId = await this.jsonRpcSenders.send(method, params);\n      throwIfCancelled(isCancelled);\n      subscription.physicalId = physicalId;\n      this.virtualIdsByPhysicalId.set(physicalId, virtualId);\n      switch (params[0]) {\n        case \"newHeads\": {\n          const backfillEvents = await withBackoffRetries(\n            () =>\n              withTimeout(\n                this.backfiller.getNewHeadsBackfill(\n                  isCancelled,\n                  sentEvents,\n                  startingBlockNumber,\n                ),\n                BACKFILL_TIMEOUT,\n              ),\n            BACKFILL_RETRIES,\n            () => !isCancelled(),\n          );\n          throwIfCancelled(isCancelled);\n          const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);\n          events.forEach((event) => this.emitNewHeadsEvent(virtualId, event));\n          break;\n        }\n        case \"logs\": {\n          const filter: LogsSubscriptionFilter = params[1] || {};\n          const backfillEvents = await withBackoffRetries(\n            () =>\n              withTimeout(\n                this.backfiller.getLogsBackfill(\n                  isCancelled,\n                  filter,\n                  sentEvents,\n                  startingBlockNumber,\n                ),\n                BACKFILL_TIMEOUT,\n              ),\n            BACKFILL_RETRIES,\n            () => !isCancelled(),\n          );\n          throwIfCancelled(isCancelled);\n          const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);\n          events.forEach((event) => this.emitLogsEvent(virtualId, event));\n          break;\n        }\n        default:\n          break;\n      }\n    } finally {\n      subscription.isBackfilling = false;\n      backfillBuffer.length = 0;\n    }\n  }\n\n  private async getBlockNumber(): Promise<number> {\n    const blockNumberHex: string = await this.jsonRpcSenders.send(\n      \"eth_blockNumber\",\n    );\n    return fromHex(blockNumberHex);\n  }\n\n  private emitNewHeadsEvent(virtualId: string, result: NewHeadsEvent): void {\n    this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n  }\n\n  private emitLogsEvent(virtualId: string, result: LogsEvent): void {\n    this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n  }\n\n  /**\n   * Emits an event to consumers, but also remembers it in its subscriptions's\n   * `sentEvents` buffer so that we can detect re-orgs if the connection drops\n   * and needs to be reconnected.\n   */\n  private emitAndRememberEvent<T>(\n    virtualId: string,\n    result: T,\n    getBlockNumber: (result: T) => number,\n  ): void {\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    // Web3 modifies these event objects once we pass them on (changing hex\n    // numbers to numbers). We want the original event, so make a defensive\n    // copy.\n    addToPastEventsBuffer(\n      subscription.sentEvents,\n      { ...result },\n      getBlockNumber,\n    );\n    this.emitGenericEvent(virtualId, result);\n  }\n\n  private emitGenericEvent(virtualId: string, result: any): void {\n    const event: SubscriptionEvent = {\n      jsonrpc: \"2.0\",\n      method: \"eth_subscription\",\n      params: {\n        subscription: virtualId,\n        result,\n      },\n    };\n    this.emit(\"data\", event);\n  }\n}\n\nfunction addToNewHeadsEventsBuffer(\n  pastEvents: NewHeadsEvent[],\n  event: NewHeadsEvent,\n): void {\n  addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\n}\n\nfunction addToLogsEventsBuffer(\n  pastEvents: LogsEvent[],\n  event: LogsEvent,\n): void {\n  addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\n}\n\n/**\n * Adds a new event to an array of events, evicting any events which\n * are so old that they will no longer feasibly be part of a reorg.\n */\nfunction addToPastEventsBuffer<T>(\n  pastEvents: T[],\n  event: T,\n  getBlockNumber: (event: T) => number,\n): void {\n  const currentBlockNumber = getBlockNumber(event);\n  // Find first index of an event recent enough to retain, then drop everything\n  // at a lower index.\n  const firstGoodIndex = pastEvents.findIndex(\n    (e) => getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT,\n  );\n  if (firstGoodIndex === -1) {\n    pastEvents.length = 0;\n  } else {\n    pastEvents.splice(0, firstGoodIndex);\n  }\n  pastEvents.push(event);\n}\n\nfunction isSubscribeRequest(\n  request: SingleOrBatchRequest,\n): request is JsonRpcRequest {\n  return !Array.isArray(request) && request.method === \"eth_subscribe\";\n}\n\nfunction isUnsubscribeRequest(\n  request: SingleOrBatchRequest,\n): request is JsonRpcRequest {\n  return !Array.isArray(request) && request.method === \"eth_unsubscribe\";\n}\n\nfunction getNewHeadsBlockNumber(event: NewHeadsEvent): number {\n  return fromHex(event.number);\n}\n\nfunction getLogsBlockNumber(event: LogsEvent): number {\n  return fromHex(event.blockNumber);\n}\n\nfunction noop(): void {\n  // Nothing.\n}\n"],"mappings":";AAAA,OAAOA,YAAY,MAAM,eAAe;AAExC,SAEEC,UAAU,EACVC,cAAc,EAGdC,cAAc,QAET,uCAAuC;AAC9C,SACEC,mBAAmB,QAOd,UAAU;AACjB,SAASC,OAAO,QAAQ,aAAa;AACrC,SAAyBC,YAAY,QAAQ,iBAAiB;AAC9D,SACEC,YAAY,EACZC,eAAe,EACfC,gBAAgB,EAChBC,kBAAkB,EAClBC,WAAW,QACN,kBAAkB;AAGzB,IAAMC,kBAAkB,GAAG,KAAK;AAChC,IAAMC,mBAAmB,GAAG,KAAK;AACjC,IAAMC,gBAAgB,GAAG,KAAK;AAC9B,IAAMC,gBAAgB,GAAG,CAAC;AAC1B;;;;;;;;;;AAUA,IAAMC,0BAA0B,GAAG,EAAE;AAgDrC,IAAAC,wBAAA,0BAAAC,MAAA;EACUC,SAAA,CAAAF,wBAAA,EAAAC,MAAA;EAgBR,SAAAD,yBACmBG,EAAmB,EACnBC,kBAA8C,EAC9CC,cAA8B;IAHjD,IAAAC,KAAA,GAKEL,MAAA,CAAAM,IAAA,MAAO;IAJUD,KAAA,CAAAH,EAAE,GAAFA,EAAE;IACFG,KAAA,CAAAF,kBAAkB,GAAlBA,kBAAkB;IAClBE,KAAA,CAAAD,cAAc,GAAdA,cAAc;IAhBjC;IACA;IACA;IACA;IACA;IACA;IACiBC,KAAA,CAAAE,wBAAwB,GACvC,IAAIC,GAAG,EAAE;IACMH,KAAA,CAAAI,sBAAsB,GAAwB,IAAID,GAAG,EAAE;IAGhEH,KAAA,CAAAK,cAAc,GAAGC,IAAI;IAuGrBN,KAAA,CAAAO,cAAc,GAAG;MACvB,IAAIP,KAAI,CAACQ,mBAAmB,IAAI,IAAI,EAAE;QACpC;;MAEFR,KAAI,CAACQ,mBAAmB,GAAGC,WAAW,CAAC;QAAA,OAAAC,SAAA,CAAAV,KAAA;;;;;;gBAEnC,qBAAMZ,WAAW,CACf,IAAI,CAACW,cAAc,CAACY,IAAI,CAAC,aAAa,CAAC,EACvCrB,mBAAmB,CACpB;;gBAHDsB,EAAA,CAAAC,IAAA,EAGC;;;;gBAED,IAAI,CAAChB,EAAE,CAACiB,SAAS,EAAE;;;;;;;OAEtB,EAAEzB,kBAAkB,CAAC;IACxB,CAAC;IAEOW,KAAA,CAAAe,wBAAwB,GAAG;MACjC,IAAIf,KAAI,CAACQ,mBAAmB,IAAI,IAAI,EAAE;QACpCQ,aAAa,CAAChB,KAAI,CAACQ,mBAAmB,CAAC;QACvCR,KAAI,CAACQ,mBAAmB,GAAGS,SAAS;;MAEtCjB,KAAI,CAACK,cAAc,EAAE;IACvB,CAAC;IAEOL,KAAA,CAAAkB,aAAa,GAAG,UAACC,KAAmB;MAC1C,IAAMC,OAAO,GAAqBC,IAAI,CAACC,KAAK,CAACH,KAAK,CAACI,IAAI,CAAC;MACxD,IAAI,CAAC1C,mBAAmB,CAACuC,OAAO,CAAC,EAAE;QACjC;;MAEF,IAAMI,UAAU,GAAGJ,OAAO,CAACK,MAAM,CAACC,YAAY;MAC9C,IAAMC,SAAS,GAAG3B,KAAI,CAACI,sBAAsB,CAACwB,GAAG,CAACJ,UAAU,CAAC;MAC7D,IAAI,CAACG,SAAS,EAAE;QACd;;MAEF,IAAMD,YAAY,GAAG1B,KAAI,CAACE,wBAAwB,CAAC0B,GAAG,CAACD,SAAS,CAAE;MAClE,IAAID,YAAY,CAACG,MAAM,KAAK,eAAe,EAAE;QAC3C7B,KAAI,CAAC8B,gBAAgB,CAACH,SAAS,EAAEP,OAAO,CAACK,MAAM,CAACM,MAAM,CAAC;QACvD;;MAEF,QAAQL,YAAY,CAACD,MAAM,CAAC,CAAC,CAAC;QAC5B,KAAK,UAAU;UAAE;YACf,IAAMO,oBAAoB,GAAGN,YAAoC;YACjE,IAAMO,eAAe,GAAGb,OAA2C;YAC3D,IAAAc,aAAa,GAAqBF,oBAAoB,CAAAE,aAAzC;cAAEC,cAAc,GAAKH,oBAAoB,CAAAG,cAAzB;YAC7B,IAAAJ,MAAM,GAAKE,eAAe,CAACR,MAAM,CAAAM,MAA3B;YACd,IAAIG,aAAa,EAAE;cACjBE,yBAAyB,CAACD,cAAc,EAAEJ,MAAM,CAAC;aAClD,MAAM;cACL/B,KAAI,CAACqC,iBAAiB,CAACV,SAAS,EAAEI,MAAM,CAAC;;YAE3C;;QAEF,KAAK,MAAM;UAAE;YACX,IAAMO,gBAAgB,GAAGZ,YAAgC;YACzD,IAAMa,WAAW,GAAGnB,OAAuC;YACnD,IAAAc,aAAa,GAAqBI,gBAAgB,CAAAJ,aAArC;cAAEC,cAAc,GAAKG,gBAAgB,CAAAH,cAArB;YAC7B,IAAAJ,MAAM,GAAKQ,WAAW,CAACd,MAAM,CAAAM,MAAvB;YACd,IAAIG,aAAa,EAAE;cACjBM,qBAAqB,CAACL,cAAc,EAAEJ,MAAM,CAAC;aAC9C,MAAM;cACL/B,KAAI,CAACyC,aAAa,CAACd,SAAS,EAAEI,MAAM,CAAC;;YAEvC;;QAEF;UACE/B,KAAI,CAAC8B,gBAAgB,CAACH,SAAS,EAAEP,OAAO,CAACK,MAAM,CAACM,MAAM,CAAC;MAAC;IAE9D,CAAC;IAEO/B,KAAA,CAAA0C,YAAY,GAAG;;MACrB1C,KAAI,CAACI,sBAAsB,CAACuC,KAAK,EAAE;MAC7B,IAAA/B,EAAA,GAA0B3B,eAAe,EAAE;QAAzC2D,MAAM,GAAAhC,EAAA,CAAAgC,MAAA;QAAEC,WAAW,GAAAjC,EAAA,CAAAiC,WAAsB;MACjD7C,KAAI,CAACK,cAAc,GAAGuC,MAAM;8BACjBlB,YAAY;QACrB,CAAC;UAAA,OAAAhB,SAAA,CAAAV,KAAA;;;;;;kBAEG,qBAAM,IAAI,CAAC8C,sBAAsB,CAACD,WAAW,EAAEnB,YAAY,CAAC;;kBAA5DqB,EAAA,CAAAlC,IAAA,EAA4D;;;;kBAE5D,IAAI,CAACgC,WAAW,EAAE,EAAE;oBAClBG,OAAO,CAACC,KAAK,CACX,+BAA4BvB,YAAY,CAACD,MAAM,CAAC,CAAC,CAAC,iDAA6C,EAC/FyB,OAAK,CACN;;;;;;;;SAGN,GAAG;;;;QAZN,KAA2B,IAAAC,EAAA,GAAAC,QAAA,CAAApD,KAAI,CAACE,wBAAwB,CAACmD,MAAM,EAAE,GAAAC,EAAA,GAAAH,EAAA,CAAAI,IAAA,KAAAD,EAAA,CAAAE,IAAA,EAAAF,EAAA,GAAAH,EAAA,CAAAI,IAAA;UAA5D,IAAM7B,YAAY,GAAA4B,EAAA,CAAAG,KAAA;kBAAZ/B,YAAY;;;;;;;;;;;;;MAcvB1B,KAAI,CAACO,cAAc,EAAE;IACvB,CAAC;IAvLCP,KAAI,CAAC0D,UAAU,GAAG9E,cAAc,CAACmB,cAAc,CAAC;IAChDC,KAAI,CAAC2D,kBAAkB,EAAE;IACzB3D,KAAI,CAACO,cAAc,EAAE;;EACvB;EAEOb,wBAAA,CAAAkE,SAAA,CAAAjD,IAAI,GAAX,UACEkD,OAA6B,EAC7BC,QAAgE;IAEhE,IAAIC,kBAAkB,CAACF,OAAO,CAAC,EAAE;MACvB,IAAAG,EAAE,GAAKH,OAAO,CAAAG,EAAZ;MACV,IAAIA,EAAE,KAAK/C,SAAS,EAAE;QACpB;QACA;;MAEFjC,YAAY,CAAC,IAAI,CAACiF,SAAS,CAACJ,OAAO,CAAC,EAAEC,QAAQ,CAAC;MAC/C;;IAEF,IAAII,oBAAoB,CAACL,OAAO,CAAC,EAAE;MACjC7E,YAAY,CAAC,IAAI,CAACmF,WAAW,CAACN,OAAO,CAAC,EAAEC,QAAQ,CAAC;MACjD;;IAEF9E,YAAY,CAAC,IAAI,CAACc,kBAAkB,CAAC+D,OAAO,CAAC,EAAEC,QAAQ,CAAC;EAC1D,CAAC;EAEMpE,wBAAA,CAAAkE,SAAA,CAAAQ,qBAAqB,GAA5B;IACE,OAAO,IAAI;EACb,CAAC;EAEM1E,wBAAA,CAAAkE,SAAA,CAAAS,UAAU,GAAjB,UAAkBC,IAAa,EAAEC,MAAe;IAC9C,IAAI,CAACC,qBAAqB,EAAE;IAC5B,IAAI,CAACC,kBAAkB,EAAE;IACzB,IAAI,CAAC1D,wBAAwB,EAAE;IAC/B,IAAI,CAAClB,EAAE,CAAC6E,KAAK,CAACJ,IAAI,EAAEC,MAAM,CAAC;EAC7B,CAAC;EAEM7E,wBAAA,CAAAkE,SAAA,CAAAe,OAAO,GAAd;IACE;IACA;EAAA,CACD;EAEMjF,wBAAA,CAAAkE,SAAA,CAAAgB,KAAK,GAAZ;IACE;EAAA,CACD;EAEMlF,wBAAA,CAAAkE,SAAA,CAAA9C,SAAS,GAAhB;IACE;EAAA,CACD;EAEapB,wBAAA,CAAAkE,SAAA,CAAAK,SAAS,GAAvB,UAAwBJ,OAAuB;;;;;;YACrChC,MAAM,GAAkBgC,OAAO,CAAAhC,MAAzB,EAAEkB,EAAA,GAAgBc,OAAO,CAAApC,MAAZ,EAAXA,MAAM,GAAAsB,EAAA,cAAG,EAAE,GAAAA,EAAA;YACC,qBAAM,IAAI,CAAC8B,cAAc,EAAE;;YAAjDC,mBAAmB,GAAGlE,EAAA,CAAAC,IAAA,EAA2B;YACtC,qBAAM,IAAI,CAACf,kBAAkB,CAAC+D,OAAO,CAAC;;YAAjDkB,QAAQ,GAAGnE,EAAA,CAAAC,IAAA,EAAsC;YACjDmD,EAAE,GAAGe,QAAQ,CAAChD,MAAM;YAC1B,IAAI,CAAC7B,wBAAwB,CAAC8E,GAAG,CAAChB,EAAE,EAAE;cACpCnC,MAAM,EAAAA,MAAA;cACNJ,MAAM,EAAAA,MAAA;cACNqD,mBAAmB,EAAAA,mBAAA;cACnBnD,SAAS,EAAEqC,EAAE;cACbxC,UAAU,EAAEwC,EAAE;cACdiB,UAAU,EAAE,EAAE;cACd/C,aAAa,EAAE,KAAK;cACpBC,cAAc,EAAE;aACjB,CAAC;YACF,IAAI,CAAC/B,sBAAsB,CAAC4E,GAAG,CAAChB,EAAE,EAAEA,EAAE,CAAC;YACvC,sBAAOjF,YAAY,CAAC8E,OAAO,CAACG,EAAG,EAAEA,EAAE,CAAC;QAAC;;;GACtC;EAEatE,wBAAA,CAAAkE,SAAA,CAAAO,WAAW,GAAzB,UAA0BN,OAAuB;;;;;;;YACzCqB,cAAc,GAAG,CAAAnC,EAAA,GAAAc,OAAO,CAACpC,MAAM,cAAAsB,EAAA,uBAAAA,EAAA,CAAG,CAAC,CAAC;YACpCoC,mBAAmB,GACvB,IAAI,CAACjF,wBAAwB,CAAC0B,GAAG,CAACsD,cAAc,CAAC;YACnD,IAAI,CAACC,mBAAmB,EAAE;cACxB,sBAAOpG,YAAY,CAAC8E,OAAO,CAACG,EAAG,EAAE,KAAK,CAAC;;YAEjCxC,UAAU,GAAK2D,mBAAmB,CAAA3D,UAAxB;YACZ4D,eAAe,GAAAC,QAAA,CAAAA,QAAA,KAAQxB,OAAO;cAAEpC,MAAM,EAAE,CAACD,UAAU;YAAC,EAAE;YAC5D,qBAAM,IAAI,CAAC1B,kBAAkB,CAACsF,eAAe,CAAC;;YAA9CxE,EAAA,CAAAC,IAAA,EAA8C;YAC9C,IAAI,CAACX,wBAAwB,CAACoF,MAAM,CAACJ,cAAc,CAAC;YACpD,IAAI,CAAC9E,sBAAsB,CAACkF,MAAM,CAAC9D,UAAU,CAAC;YAC9C,sBAAOzC,YAAY,CAAC8E,OAAO,CAACG,EAAG,EAAE,IAAI,CAAC;QAAC;;;GACxC;EAEOtE,wBAAA,CAAAkE,SAAA,CAAAD,kBAAkB,GAA1B;IACE,IAAI,CAAC9D,EAAE,CAAC0F,gBAAgB,CAAC,SAAS,EAAE,IAAI,CAACrE,aAAa,CAAC;IACvD,IAAI,CAACrB,EAAE,CAAC0F,gBAAgB,CAAC,QAAQ,EAAE,IAAI,CAAC7C,YAAY,CAAC;IACrD,IAAI,CAAC7C,EAAE,CAAC0F,gBAAgB,CAAC,MAAM,EAAE,IAAI,CAACxE,wBAAwB,CAAC;EACjE,CAAC;EAEOrB,wBAAA,CAAAkE,SAAA,CAAAY,qBAAqB,GAA7B;IACE,IAAI,CAAC3E,EAAE,CAAC2F,mBAAmB,CAAC,SAAS,EAAE,IAAI,CAACtE,aAAa,CAAC;IAC1D,IAAI,CAACrB,EAAE,CAAC2F,mBAAmB,CAAC,QAAQ,EAAE,IAAI,CAAC9C,YAAY,CAAC;IACxD,IAAI,CAAC7C,EAAE,CAAC2F,mBAAmB,CAAC,MAAM,EAAE,IAAI,CAACzE,wBAAwB,CAAC;EACpE,CAAC;EA4FarB,wBAAA,CAAAkE,SAAA,CAAAd,sBAAsB,GAApC,UACED,WAA0B,EAC1BnB,YAAiC;;;;;;;YAG/BC,SAAS,GAMPD,YAAY,CAAAC,SANL,EACTE,MAAM,GAKJH,YAAY,CAAAG,MALR,EACNJ,MAAM,GAIJC,YAAY,CAAAD,MAJR,EACNwD,UAAU,GAGRvD,YAAY,CAAAuD,UAHJ,EACV9C,cAAc,GAEZT,YAAY,CAAAS,cAFA,EACd2C,mBAAmB,GACjBpD,YAAY,CAAAoD,mBADK;YAErBpD,YAAY,CAACQ,aAAa,GAAG,IAAI;YACjCC,cAAc,CAACsD,MAAM,GAAG,CAAC;;;;YAEJ,qBAAM,IAAI,CAAC1F,cAAc,CAACY,IAAI,CAACkB,MAAM,EAAEJ,MAAM,CAAC;;YAA3DD,UAAU,GAAGZ,EAAA,CAAAC,IAAA,EAA8C;YACjE3B,gBAAgB,CAAC2D,WAAW,CAAC;YAC7BnB,YAAY,CAACF,UAAU,GAAGA,UAAU;YACpC,IAAI,CAACpB,sBAAsB,CAAC4E,GAAG,CAACxD,UAAU,EAAEG,SAAS,CAAC;YAC9CoB,EAAA,GAAAtB,MAAM,CAAC,CAAC,CAAC;;mBACV,UAAU;gBAAV;mBAmBA,MAAM;gBAAN;YAAM;;;YAlBc,qBAAMtC,kBAAkB,CAC7C;cACE,OAAAC,WAAW,CACTY,KAAI,CAAC0D,UAAU,CAACgC,mBAAmB,CACjC7C,WAAW,EACXoC,UAAU,EACVH,mBAAmB,CACpB,EACDvF,gBAAgB,CACjB;YAPD,CAOC,EACHC,gBAAgB,EAChB;cAAM,QAACqD,WAAW,EAAE;YAAd,CAAc,CACrB;;YAZK8C,cAAc,GAAG/E,EAAA,CAAAC,IAAA,EAYtB;YACD3B,gBAAgB,CAAC2D,WAAW,CAAC;YACvB+C,MAAM,GAAGjH,cAAc,CAAAkH,aAAA,CAAAA,aAAA,KAAAC,MAAA,CAAKH,cAAc,IAAAG,MAAA,CAAK3D,cAAc,GAAE;YACrEyD,MAAM,CAACG,OAAO,CAAC,UAAC5E,KAAK;cAAK,OAAAnB,KAAI,CAACqC,iBAAiB,CAACV,SAAS,EAAER,KAAK,CAAC;YAAxC,CAAwC,CAAC;YACnE;;YAGM6E,QAAA,GAAiCvE,MAAM,CAAC,CAAC,CAAC,IAAI,EAAE;YAC/B,qBAAMtC,kBAAkB,CAC7C;cACE,OAAAC,WAAW,CACTY,KAAI,CAAC0D,UAAU,CAACuC,eAAe,CAC7BpD,WAAW,EACXmD,QAAM,EACNf,UAAU,EACVH,mBAAmB,CACpB,EACDvF,gBAAgB,CACjB;YARD,CAQC,EACHC,gBAAgB,EAChB;cAAM,QAACqD,WAAW,EAAE;YAAd,CAAc,CACrB;;YAbK8C,cAAc,GAAG/E,EAAA,CAAAC,IAAA,EAatB;YACD3B,gBAAgB,CAAC2D,WAAW,CAAC;YACvB+C,MAAM,GAAGlH,UAAU,CAAAmH,aAAA,CAAAA,aAAA,KAAAC,MAAA,CAAKH,cAAc,IAAAG,MAAA,CAAK3D,cAAc,GAAE;YACjEyD,MAAM,CAACG,OAAO,CAAC,UAAC5E,KAAK;cAAK,OAAAnB,KAAI,CAACyC,aAAa,CAACd,SAAS,EAAER,KAAK,CAAC;YAApC,CAAoC,CAAC;YAC/D;;YAGA;;;;YAGJO,YAAY,CAACQ,aAAa,GAAG,KAAK;YAClCC,cAAc,CAACsD,MAAM,GAAG,CAAC;;;;;;;GAE5B;;EAEa/F,wBAAA,CAAAkE,SAAA,CAAAiB,cAAc,GAA5B;;;;;;YACiC,qBAAM,IAAI,CAAC9E,cAAc,CAACY,IAAI,CAC3D,iBAAiB,CAClB;;YAFKuF,cAAc,GAAWnD,EAAA,CAAAlC,IAAA,EAE9B;YACD,sBAAO/B,OAAO,CAACoH,cAAc,CAAC;QAAC;;;GAChC;EAEOxG,wBAAA,CAAAkE,SAAA,CAAAvB,iBAAiB,GAAzB,UAA0BV,SAAiB,EAAEI,MAAqB;IAChE,IAAI,CAACoE,oBAAoB,CAACxE,SAAS,EAAEI,MAAM,EAAEqE,sBAAsB,CAAC;EACtE,CAAC;EAEO1G,wBAAA,CAAAkE,SAAA,CAAAnB,aAAa,GAArB,UAAsBd,SAAiB,EAAEI,MAAiB;IACxD,IAAI,CAACoE,oBAAoB,CAACxE,SAAS,EAAEI,MAAM,EAAEsE,kBAAkB,CAAC;EAClE,CAAC;EAED;;;;;EAKQ3G,wBAAA,CAAAkE,SAAA,CAAAuC,oBAAoB,GAA5B,UACExE,SAAiB,EACjBI,MAAS,EACT8C,cAAqC;IAErC,IAAMnD,YAAY,GAAG,IAAI,CAACxB,wBAAwB,CAAC0B,GAAG,CAACD,SAAS,CAAC;IACjE,IAAI,CAACD,YAAY,EAAE;MACjB;;IAEF;IACA;IACA;IACA4E,qBAAqB,CACnB5E,YAAY,CAACuD,UAAU,EAAAI,QAAA,KAClBtD,MAAM,GACX8C,cAAc,CACf;IACD,IAAI,CAAC/C,gBAAgB,CAACH,SAAS,EAAEI,MAAM,CAAC;EAC1C,CAAC;EAEOrC,wBAAA,CAAAkE,SAAA,CAAA9B,gBAAgB,GAAxB,UAAyBH,SAAiB,EAAEI,MAAW;IACrD,IAAMZ,KAAK,GAAsB;MAC/BoF,OAAO,EAAE,KAAK;MACd1E,MAAM,EAAE,kBAAkB;MAC1BJ,MAAM,EAAE;QACNC,YAAY,EAAEC,SAAS;QACvBI,MAAM,EAAAA;;KAET;IACD,IAAI,CAACyE,IAAI,CAAC,MAAM,EAAErF,KAAK,CAAC;EAC1B,CAAC;EACH,OAAAzB,wBAAC;AAAD,CAAC,CAvUSjB,YAAY;;AAyUtB,SAAS2D,yBAAyBA,CAChCqE,UAA2B,EAC3BtF,KAAoB;EAEpBmF,qBAAqB,CAACG,UAAU,EAAEtF,KAAK,EAAEiF,sBAAsB,CAAC;AAClE;AAEA,SAAS5D,qBAAqBA,CAC5BiE,UAAuB,EACvBtF,KAAgB;EAEhBmF,qBAAqB,CAACG,UAAU,EAAEtF,KAAK,EAAEkF,kBAAkB,CAAC;AAC9D;AAEA;;;;AAIA,SAASC,qBAAqBA,CAC5BG,UAAe,EACftF,KAAQ,EACR0D,cAAoC;EAEpC,IAAM6B,kBAAkB,GAAG7B,cAAc,CAAC1D,KAAK,CAAC;EAChD;EACA;EACA,IAAMwF,cAAc,GAAGF,UAAU,CAACG,SAAS,CACzC,UAACC,CAAC;IAAK,OAAAhC,cAAc,CAACgC,CAAC,CAAC,GAAGH,kBAAkB,GAAGjH,0BAA0B;EAAnE,CAAmE,CAC3E;EACD,IAAIkH,cAAc,KAAK,CAAC,CAAC,EAAE;IACzBF,UAAU,CAAChB,MAAM,GAAG,CAAC;GACtB,MAAM;IACLgB,UAAU,CAACK,MAAM,CAAC,CAAC,EAAEH,cAAc,CAAC;;EAEtCF,UAAU,CAACM,IAAI,CAAC5F,KAAK,CAAC;AACxB;AAEA,SAAS4C,kBAAkBA,CACzBF,OAA6B;EAE7B,OAAO,CAACmD,KAAK,CAACC,OAAO,CAACpD,OAAO,CAAC,IAAIA,OAAO,CAAChC,MAAM,KAAK,eAAe;AACtE;AAEA,SAASqC,oBAAoBA,CAC3BL,OAA6B;EAE7B,OAAO,CAACmD,KAAK,CAACC,OAAO,CAACpD,OAAO,CAAC,IAAIA,OAAO,CAAChC,MAAM,KAAK,iBAAiB;AACxE;AAEA,SAASuE,sBAAsBA,CAACjF,KAAoB;EAClD,OAAOrC,OAAO,CAACqC,KAAK,CAAC+F,MAAM,CAAC;AAC9B;AAEA,SAASb,kBAAkBA,CAAClF,KAAgB;EAC1C,OAAOrC,OAAO,CAACqC,KAAK,CAACgG,WAAW,CAAC;AACnC;AAEA,SAAS7G,IAAIA,CAAA;EACX;AAAA"},"metadata":{},"sourceType":"module"}