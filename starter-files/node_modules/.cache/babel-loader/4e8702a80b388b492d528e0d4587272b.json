{"ast":null,"code":"/* @flow */\n/*::\n\ntype DotenvParseOptions = {\n  debug?: boolean\n}\n\n// keys and values from src\ntype DotenvParseOutput = { [string]: string }\n\ntype DotenvConfigOptions = {\n  path?: string, // path to .env file\n  encoding?: string, // encoding of .env file\n  debug?: string // turn on logging for debugging purposes\n}\n\ntype DotenvConfigOutput = {\n  parsed?: DotenvParseOutput,\n  error?: Error\n}\n\n*/\n\nconst fs = require('fs');\nconst path = require('path');\nfunction log(message /*: string */) {\n  console.log(`[dotenv][DEBUG] ${message}`);\n}\nconst NEWLINE = '\\n';\nconst RE_INI_KEY_VAL = /^\\s*([\\w.-]+)\\s*=\\s*(.*)?\\s*$/;\nconst RE_NEWLINES = /\\\\n/g;\nconst NEWLINES_MATCH = /\\r\\n|\\n|\\r/;\n\n// Parses src into an Object\nfunction parse(src /*: string | Buffer */, options /*: ?DotenvParseOptions */) /*: DotenvParseOutput */{\n  const debug = Boolean(options && options.debug);\n  const obj = {};\n\n  // convert Buffers before splitting into lines and processing\n  src.toString().split(NEWLINES_MATCH).forEach(function (line, idx) {\n    // matching \"KEY' and 'VAL' in 'KEY=VAL'\n    const keyValueArr = line.match(RE_INI_KEY_VAL);\n    // matched?\n    if (keyValueArr != null) {\n      const key = keyValueArr[1];\n      // default undefined or missing values to empty string\n      let val = keyValueArr[2] || '';\n      const end = val.length - 1;\n      const isDoubleQuoted = val[0] === '\"' && val[end] === '\"';\n      const isSingleQuoted = val[0] === \"'\" && val[end] === \"'\";\n\n      // if single or double quoted, remove quotes\n      if (isSingleQuoted || isDoubleQuoted) {\n        val = val.substring(1, end);\n\n        // if double quoted, expand newlines\n        if (isDoubleQuoted) {\n          val = val.replace(RE_NEWLINES, NEWLINE);\n        }\n      } else {\n        // remove surrounding whitespace\n        val = val.trim();\n      }\n      obj[key] = val;\n    } else if (debug) {\n      log(`did not match key and value when parsing line ${idx + 1}: ${line}`);\n    }\n  });\n  return obj;\n}\n\n// Populates process.env from .env file\nfunction config(options /*: ?DotenvConfigOptions */) /*: DotenvConfigOutput */{\n  let dotenvPath = path.resolve(process.cwd(), '.env');\n  let encoding /*: string */ = 'utf8';\n  let debug = false;\n  if (options) {\n    if (options.path != null) {\n      dotenvPath = options.path;\n    }\n    if (options.encoding != null) {\n      encoding = options.encoding;\n    }\n    if (options.debug != null) {\n      debug = true;\n    }\n  }\n  try {\n    // specifying an encoding returns a string instead of a buffer\n    const parsed = parse(fs.readFileSync(dotenvPath, {\n      encoding\n    }), {\n      debug\n    });\n    Object.keys(parsed).forEach(function (key) {\n      if (!Object.prototype.hasOwnProperty.call(process.env, key)) {\n        process.env[key] = parsed[key];\n      } else if (debug) {\n        log(`\"${key}\" is already defined in \\`process.env\\` and will not be overwritten`);\n      }\n    });\n    return {\n      parsed\n    };\n  } catch (e) {\n    return {\n      error: e\n    };\n  }\n}\nmodule.exports.config = config;\nmodule.exports.parse = parse;","map":{"version":3,"names":["fs","require","path","log","message","console","NEWLINE","RE_INI_KEY_VAL","RE_NEWLINES","NEWLINES_MATCH","parse","src","options","debug","Boolean","obj","toString","split","forEach","line","idx","keyValueArr","match","key","val","end","length","isDoubleQuoted","isSingleQuoted","substring","replace","trim","config","dotenvPath","resolve","process","cwd","encoding","parsed","readFileSync","Object","keys","prototype","hasOwnProperty","call","env","e","error","module","exports"],"sources":["C:/Users/jack/git/hackathon/starter-files/node_modules/dotenv/lib/main.js"],"sourcesContent":["/* @flow */\n/*::\n\ntype DotenvParseOptions = {\n  debug?: boolean\n}\n\n// keys and values from src\ntype DotenvParseOutput = { [string]: string }\n\ntype DotenvConfigOptions = {\n  path?: string, // path to .env file\n  encoding?: string, // encoding of .env file\n  debug?: string // turn on logging for debugging purposes\n}\n\ntype DotenvConfigOutput = {\n  parsed?: DotenvParseOutput,\n  error?: Error\n}\n\n*/\n\nconst fs = require('fs')\nconst path = require('path')\n\nfunction log (message /*: string */) {\n  console.log(`[dotenv][DEBUG] ${message}`)\n}\n\nconst NEWLINE = '\\n'\nconst RE_INI_KEY_VAL = /^\\s*([\\w.-]+)\\s*=\\s*(.*)?\\s*$/\nconst RE_NEWLINES = /\\\\n/g\nconst NEWLINES_MATCH = /\\r\\n|\\n|\\r/\n\n// Parses src into an Object\nfunction parse (src /*: string | Buffer */, options /*: ?DotenvParseOptions */) /*: DotenvParseOutput */ {\n  const debug = Boolean(options && options.debug)\n  const obj = {}\n\n  // convert Buffers before splitting into lines and processing\n  src.toString().split(NEWLINES_MATCH).forEach(function (line, idx) {\n    // matching \"KEY' and 'VAL' in 'KEY=VAL'\n    const keyValueArr = line.match(RE_INI_KEY_VAL)\n    // matched?\n    if (keyValueArr != null) {\n      const key = keyValueArr[1]\n      // default undefined or missing values to empty string\n      let val = (keyValueArr[2] || '')\n      const end = val.length - 1\n      const isDoubleQuoted = val[0] === '\"' && val[end] === '\"'\n      const isSingleQuoted = val[0] === \"'\" && val[end] === \"'\"\n\n      // if single or double quoted, remove quotes\n      if (isSingleQuoted || isDoubleQuoted) {\n        val = val.substring(1, end)\n\n        // if double quoted, expand newlines\n        if (isDoubleQuoted) {\n          val = val.replace(RE_NEWLINES, NEWLINE)\n        }\n      } else {\n        // remove surrounding whitespace\n        val = val.trim()\n      }\n\n      obj[key] = val\n    } else if (debug) {\n      log(`did not match key and value when parsing line ${idx + 1}: ${line}`)\n    }\n  })\n\n  return obj\n}\n\n// Populates process.env from .env file\nfunction config (options /*: ?DotenvConfigOptions */) /*: DotenvConfigOutput */ {\n  let dotenvPath = path.resolve(process.cwd(), '.env')\n  let encoding /*: string */ = 'utf8'\n  let debug = false\n\n  if (options) {\n    if (options.path != null) {\n      dotenvPath = options.path\n    }\n    if (options.encoding != null) {\n      encoding = options.encoding\n    }\n    if (options.debug != null) {\n      debug = true\n    }\n  }\n\n  try {\n    // specifying an encoding returns a string instead of a buffer\n    const parsed = parse(fs.readFileSync(dotenvPath, { encoding }), { debug })\n\n    Object.keys(parsed).forEach(function (key) {\n      if (!Object.prototype.hasOwnProperty.call(process.env, key)) {\n        process.env[key] = parsed[key]\n      } else if (debug) {\n        log(`\"${key}\" is already defined in \\`process.env\\` and will not be overwritten`)\n      }\n    })\n\n    return { parsed }\n  } catch (e) {\n    return { error: e }\n  }\n}\n\nmodule.exports.config = config\nmodule.exports.parse = parse\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}