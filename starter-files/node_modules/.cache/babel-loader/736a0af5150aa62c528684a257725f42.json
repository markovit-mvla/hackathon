{"ast":null,"code":"import { __assign, __awaiter, __generator, __read, __spreadArray } from \"tslib\";\nimport { fromHex, toHex } from \"../util/hex\";\nimport { throwIfCancelled } from \"../util/promises\";\n/**\n * The maximum number of blocks to backfill. If more than this many blocks have\n * been missed, then we'll sadly miss data, but we want to make sure we don't\n * end up requesting thousands of blocks if somebody left their laptop closed\n * for a week.\n */\nvar MAX_BACKFILL_BLOCKS = 120;\n/**\n * The maximum number of requests that can be included in a single batch request.\n * This value is enforced by the backend.\n */\nvar MAX_BATCH_SIZE = 10;\nexport function makeBackfiller(jsonRpcSenders) {\n  return {\n    getNewHeadsBackfill: getNewHeadsBackfill,\n    getLogsBackfill: getLogsBackfill\n  };\n  function getNewHeadsBackfill(isCancelled, previousHeads, fromBlockNumber) {\n    return __awaiter(this, void 0, void 0, function () {\n      var toBlockNumber, lastSeenBlockNumber, minBlockNumber, reorgHeads, intermediateHeads;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            throwIfCancelled(isCancelled);\n            return [4 /*yield*/, getBlockNumber()];\n          case 1:\n            toBlockNumber = _a.sent();\n            throwIfCancelled(isCancelled);\n            if (previousHeads.length === 0) {\n              return [2 /*return*/, getHeadEventsInRange(Math.max(fromBlockNumber, toBlockNumber - MAX_BACKFILL_BLOCKS) + 1, toBlockNumber + 1)];\n            }\n            lastSeenBlockNumber = fromHex(previousHeads[previousHeads.length - 1].number);\n            minBlockNumber = Math.max(0, lastSeenBlockNumber - MAX_BACKFILL_BLOCKS);\n            if (lastSeenBlockNumber < minBlockNumber) {\n              return [2 /*return*/, getHeadEventsInRange(minBlockNumber, toBlockNumber + 1)];\n            }\n            return [4 /*yield*/, getReorgHeads(isCancelled, previousHeads)];\n          case 2:\n            reorgHeads = _a.sent();\n            throwIfCancelled(isCancelled);\n            return [4 /*yield*/, getHeadEventsInRange(lastSeenBlockNumber + 1, toBlockNumber + 1)];\n          case 3:\n            intermediateHeads = _a.sent();\n            throwIfCancelled(isCancelled);\n            return [2 /*return*/, __spreadArray(__spreadArray([], __read(reorgHeads)), __read(intermediateHeads))];\n        }\n      });\n    });\n  }\n  function getReorgHeads(isCancelled, previousHeads) {\n    return __awaiter(this, void 0, void 0, function () {\n      var result, i, oldEvent, blockHead;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            result = [];\n            i = previousHeads.length - 1;\n            _a.label = 1;\n          case 1:\n            if (!(i >= 0)) return [3 /*break*/, 4];\n            oldEvent = previousHeads[i];\n            return [4 /*yield*/, getBlockByNumber(fromHex(oldEvent.number))];\n          case 2:\n            blockHead = _a.sent();\n            throwIfCancelled(isCancelled);\n            if (oldEvent.hash === blockHead.hash) {\n              return [3 /*break*/, 4];\n            }\n            result.push(toNewHeadsEvent(blockHead));\n            _a.label = 3;\n          case 3:\n            i--;\n            return [3 /*break*/, 1];\n          case 4:\n            return [2 /*return*/, result.reverse()];\n        }\n      });\n    });\n  }\n  function getHeadEventsInRange(fromBlockInclusive, toBlockExclusive) {\n    return __awaiter(this, void 0, void 0, function () {\n      var batchParts, headEventBatches, i, batchedBlockHeads, blockHeads;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (fromBlockInclusive >= toBlockExclusive) {\n              return [2 /*return*/, []];\n            }\n            batchParts = [];\n            headEventBatches = [];\n            for (i = fromBlockInclusive; i < toBlockExclusive; i++) {\n              batchParts.push({\n                method: \"eth_getBlockByNumber\",\n                params: [toHex(i), false]\n              });\n              if (batchParts.length % MAX_BATCH_SIZE === 0) {\n                headEventBatches.push(jsonRpcSenders.sendBatch(batchParts));\n                batchParts = [];\n              }\n            }\n            if (batchParts.length > 0) {\n              headEventBatches.push(jsonRpcSenders.sendBatch(batchParts));\n            }\n            return [4 /*yield*/, Promise.all(headEventBatches)];\n          case 1:\n            batchedBlockHeads = _a.sent();\n            blockHeads = batchedBlockHeads.reduce(function (acc, batch) {\n              return acc.concat(batch);\n            }, []);\n            return [2 /*return*/, blockHeads.map(toNewHeadsEvent)];\n        }\n      });\n    });\n  }\n  function getBlockByNumber(blockNumber) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, jsonRpcSenders.send(\"eth_getBlockByNumber\", [toHex(blockNumber), false])];\n      });\n    });\n  }\n  function getLogsBackfill(isCancelled, filter, previousLogs, fromBlockNumber) {\n    return __awaiter(this, void 0, void 0, function () {\n      var toBlockNumber, lastSeenBlockNumber, minBlockNumber, commonAncestorNumber, removedLogs, addedLogs;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            throwIfCancelled(isCancelled);\n            return [4 /*yield*/, getBlockNumber()];\n          case 1:\n            toBlockNumber = _a.sent();\n            throwIfCancelled(isCancelled);\n            if (previousLogs.length === 0) {\n              return [2 /*return*/, getLogsInRange(filter, Math.max(fromBlockNumber, toBlockNumber - MAX_BACKFILL_BLOCKS) + 1, toBlockNumber + 1)];\n            }\n            lastSeenBlockNumber = fromHex(previousLogs[previousLogs.length - 1].blockNumber);\n            minBlockNumber = Math.max(0, lastSeenBlockNumber - MAX_BACKFILL_BLOCKS);\n            if (lastSeenBlockNumber < minBlockNumber) {\n              return [2 /*return*/, getLogsInRange(filter, minBlockNumber, toBlockNumber + 1)];\n            }\n            return [4 /*yield*/, getCommonAncestorNumber(isCancelled, previousLogs)];\n          case 2:\n            commonAncestorNumber = _a.sent();\n            throwIfCancelled(isCancelled);\n            removedLogs = previousLogs.filter(function (log) {\n              return fromHex(log.blockNumber) > commonAncestorNumber;\n            }).map(function (log) {\n              return __assign(__assign({}, log), {\n                removed: true\n              });\n            });\n            return [4 /*yield*/, getLogsInRange(filter, commonAncestorNumber + 1, toBlockNumber + 1)];\n          case 3:\n            addedLogs = _a.sent();\n            throwIfCancelled(isCancelled);\n            return [2 /*return*/, __spreadArray(__spreadArray([], __read(removedLogs)), __read(addedLogs))];\n        }\n      });\n    });\n  }\n  function getCommonAncestorNumber(isCancelled, previousLogs) {\n    return __awaiter(this, void 0, void 0, function () {\n      var i, _a, blockHash, blockNumber, hash;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            i = previousLogs.length - 1;\n            _b.label = 1;\n          case 1:\n            if (!(i >= 0)) return [3 /*break*/, 4];\n            _a = previousLogs[i], blockHash = _a.blockHash, blockNumber = _a.blockNumber;\n            return [4 /*yield*/, getBlockByNumber(fromHex(blockNumber))];\n          case 2:\n            hash = _b.sent().hash;\n            throwIfCancelled(isCancelled);\n            if (blockHash === hash) {\n              return [2 /*return*/, fromHex(blockNumber)];\n            }\n            _b.label = 3;\n          case 3:\n            i--;\n            return [3 /*break*/, 1];\n          case 4:\n            return [2 /*return*/, Number.NEGATIVE_INFINITY];\n        }\n      });\n    });\n  }\n  function getLogsInRange(filter, fromBlockInclusive, toBlockExclusive) {\n    return __awaiter(this, void 0, void 0, function () {\n      var rangeFilter;\n      return __generator(this, function (_a) {\n        if (fromBlockInclusive >= toBlockExclusive) {\n          return [2 /*return*/, []];\n        }\n        rangeFilter = __assign(__assign({}, filter), {\n          fromBlock: toHex(fromBlockInclusive),\n          toBlock: toHex(toBlockExclusive - 1)\n        });\n        return [2 /*return*/, jsonRpcSenders.send(\"eth_getLogs\", [rangeFilter])];\n      });\n    });\n  }\n  function getBlockNumber() {\n    return __awaiter(this, void 0, void 0, function () {\n      var blockNumberHex;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, jsonRpcSenders.send(\"eth_blockNumber\")];\n          case 1:\n            blockNumberHex = _a.sent();\n            return [2 /*return*/, fromHex(blockNumberHex)];\n        }\n      });\n    });\n  }\n}\nfunction toNewHeadsEvent(head) {\n  var result = __assign({}, head);\n  delete result.totalDifficulty;\n  delete result.transactions;\n  delete result.uncles;\n  return result;\n}\nexport function dedupeNewHeads(events) {\n  return dedupe(events, function (event) {\n    return event.hash;\n  });\n}\nexport function dedupeLogs(events) {\n  return dedupe(events, function (event) {\n    return event.blockHash + \"/\" + event.logIndex;\n  });\n}\nfunction dedupe(items, getKey) {\n  var keysSeen = new Set();\n  var result = [];\n  items.forEach(function (item) {\n    var key = getKey(item);\n    if (!keysSeen.has(key)) {\n      keysSeen.add(key);\n      result.push(item);\n    }\n  });\n  return result;\n}","map":{"version":3,"names":["fromHex","toHex","throwIfCancelled","MAX_BACKFILL_BLOCKS","MAX_BATCH_SIZE","makeBackfiller","jsonRpcSenders","getNewHeadsBackfill","getLogsBackfill","isCancelled","previousHeads","fromBlockNumber","getBlockNumber","toBlockNumber","_a","sent","length","getHeadEventsInRange","Math","max","lastSeenBlockNumber","number","minBlockNumber","getReorgHeads","reorgHeads","intermediateHeads","__spreadArray","__read","result","i","oldEvent","getBlockByNumber","blockHead","hash","push","toNewHeadsEvent","reverse","fromBlockInclusive","toBlockExclusive","batchParts","headEventBatches","method","params","sendBatch","Promise","all","batchedBlockHeads","blockHeads","reduce","acc","batch","concat","map","blockNumber","send","filter","previousLogs","getLogsInRange","getCommonAncestorNumber","commonAncestorNumber","removedLogs","log","__assign","removed","addedLogs","blockHash","_b","Number","NEGATIVE_INFINITY","rangeFilter","fromBlock","toBlock","blockNumberHex","head","totalDifficulty","transactions","uncles","dedupeNewHeads","events","dedupe","event","dedupeLogs","logIndex","items","getKey","keysSeen","Set","forEach","item","key","has","add"],"sources":["../../../src/subscriptions/subscriptionBackfill.ts"],"sourcesContent":["import { fromHex, toHex } from \"../util/hex\";\nimport { BatchPart, JsonRpcSenders } from \"../util/jsonRpc\";\nimport { throwIfCancelled } from \"../util/promises\";\n\nexport interface NewHeadsEvent {\n  author: string;\n  difficulty: string;\n  extraData: string;\n  gasLimit: string;\n  gasUsed: string;\n  hash: string;\n  logsBloom: string;\n  miner: string;\n  mixHash: string;\n  nonce: string;\n  number: string;\n  parentHash: string;\n  receiptsRoot: string;\n  sealFields: string[];\n  sha3Uncles: string;\n  size: string;\n  stateRoot: string;\n  timestamp: string;\n  transactionsRoot: string;\n}\n\n/**\n * The return type of eth_getBlocksByHash.\n */\nexport interface BlockHead extends NewHeadsEvent {\n  totalDifficulty: string;\n  transactions: any[];\n  uncles: string[];\n}\n\nexport interface LogsEvent {\n  address: string;\n  blockHash: string;\n  blockNumber: string;\n  data: string;\n  logIndex: string;\n  topics: string[];\n  transactionHash: string;\n  transactionIndex: string;\n  removed?: boolean;\n}\n\nexport interface LogsSubscriptionFilter {\n  address?: string | string[];\n  topics?: Array<string | string[] | null>;\n}\n\ninterface GetLogsOptions extends LogsSubscriptionFilter {\n  fromBlock?: string;\n  toBlock?: string;\n}\n\nexport type Backfiller = ReturnType<typeof makeBackfiller>;\n\n/**\n * The maximum number of blocks to backfill. If more than this many blocks have\n * been missed, then we'll sadly miss data, but we want to make sure we don't\n * end up requesting thousands of blocks if somebody left their laptop closed\n * for a week.\n */\nconst MAX_BACKFILL_BLOCKS = 120;\n\n/**\n * The maximum number of requests that can be included in a single batch request.\n * This value is enforced by the backend.\n */\nconst MAX_BATCH_SIZE = 10;\n\nexport function makeBackfiller(jsonRpcSenders: JsonRpcSenders) {\n  return { getNewHeadsBackfill, getLogsBackfill };\n\n  async function getNewHeadsBackfill(\n    isCancelled: () => boolean,\n    previousHeads: NewHeadsEvent[],\n    fromBlockNumber: number,\n  ): Promise<NewHeadsEvent[]> {\n    throwIfCancelled(isCancelled);\n    const toBlockNumber = await getBlockNumber();\n    throwIfCancelled(isCancelled);\n    if (previousHeads.length === 0) {\n      return getHeadEventsInRange(\n        Math.max(fromBlockNumber, toBlockNumber - MAX_BACKFILL_BLOCKS) + 1,\n        toBlockNumber + 1,\n      );\n    }\n    const lastSeenBlockNumber = fromHex(\n      previousHeads[previousHeads.length - 1].number,\n    );\n    const minBlockNumber = Math.max(\n      0,\n      lastSeenBlockNumber - MAX_BACKFILL_BLOCKS,\n    );\n    if (lastSeenBlockNumber < minBlockNumber) {\n      return getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\n    }\n    const reorgHeads: NewHeadsEvent[] = await getReorgHeads(\n      isCancelled,\n      previousHeads,\n    );\n    throwIfCancelled(isCancelled);\n    const intermediateHeads: NewHeadsEvent[] = await getHeadEventsInRange(\n      lastSeenBlockNumber + 1,\n      toBlockNumber + 1,\n    );\n    throwIfCancelled(isCancelled);\n    return [...reorgHeads, ...intermediateHeads];\n  }\n\n  async function getReorgHeads(\n    isCancelled: () => boolean,\n    previousHeads: NewHeadsEvent[],\n  ): Promise<NewHeadsEvent[]> {\n    const result: NewHeadsEvent[] = [];\n    for (let i = previousHeads.length - 1; i >= 0; i--) {\n      const oldEvent = previousHeads[i];\n      const blockHead = await getBlockByNumber(fromHex(oldEvent.number));\n      throwIfCancelled(isCancelled);\n      if (oldEvent.hash === blockHead.hash) {\n        break;\n      }\n      result.push(toNewHeadsEvent(blockHead));\n    }\n    return result.reverse();\n  }\n\n  async function getHeadEventsInRange(\n    fromBlockInclusive: number,\n    toBlockExclusive: number,\n  ): Promise<NewHeadsEvent[]> {\n    if (fromBlockInclusive >= toBlockExclusive) {\n      return [];\n    }\n    let batchParts: BatchPart[] = [];\n    const headEventBatches: Array<Promise<BlockHead[]>> = [];\n    for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {\n      batchParts.push({\n        method: \"eth_getBlockByNumber\",\n        params: [toHex(i), false],\n      });\n      if (batchParts.length % MAX_BATCH_SIZE === 0) {\n        headEventBatches.push(jsonRpcSenders.sendBatch(batchParts));\n        batchParts = [];\n      }\n    }\n\n    if (batchParts.length > 0) {\n      headEventBatches.push(jsonRpcSenders.sendBatch(batchParts));\n    }\n\n    const batchedBlockHeads = await Promise.all(headEventBatches);\n    const blockHeads = batchedBlockHeads.reduce(\n      (acc, batch) => acc.concat(batch),\n      [],\n    );\n    return blockHeads.map(toNewHeadsEvent);\n  }\n\n  async function getBlockByNumber(blockNumber: number): Promise<BlockHead> {\n    return jsonRpcSenders.send(\"eth_getBlockByNumber\", [\n      toHex(blockNumber),\n      false,\n    ]);\n  }\n\n  async function getLogsBackfill(\n    isCancelled: () => boolean,\n    filter: LogsSubscriptionFilter,\n    previousLogs: LogsEvent[],\n    fromBlockNumber: number,\n  ): Promise<LogsEvent[]> {\n    throwIfCancelled(isCancelled);\n    const toBlockNumber = await getBlockNumber();\n    throwIfCancelled(isCancelled);\n    if (previousLogs.length === 0) {\n      return getLogsInRange(\n        filter,\n        Math.max(fromBlockNumber, toBlockNumber - MAX_BACKFILL_BLOCKS) + 1,\n        toBlockNumber + 1,\n      );\n    }\n    const lastSeenBlockNumber = fromHex(\n      previousLogs[previousLogs.length - 1].blockNumber,\n    );\n    const minBlockNumber = Math.max(\n      0,\n      lastSeenBlockNumber - MAX_BACKFILL_BLOCKS,\n    );\n    if (lastSeenBlockNumber < minBlockNumber) {\n      return getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\n    }\n    const commonAncestorNumber = await getCommonAncestorNumber(\n      isCancelled,\n      previousLogs,\n    );\n    throwIfCancelled(isCancelled);\n    const removedLogs = previousLogs\n      .filter((log) => fromHex(log.blockNumber) > commonAncestorNumber)\n      .map((log) => ({ ...log, removed: true }));\n    const addedLogs = await getLogsInRange(\n      filter,\n      commonAncestorNumber + 1,\n      toBlockNumber + 1,\n    );\n    throwIfCancelled(isCancelled);\n    return [...removedLogs, ...addedLogs];\n  }\n\n  async function getCommonAncestorNumber(\n    isCancelled: () => boolean,\n    previousLogs: LogsEvent[],\n  ): Promise<number> {\n    for (let i = previousLogs.length - 1; i >= 0; i--) {\n      const { blockHash, blockNumber } = previousLogs[i];\n      const { hash } = await getBlockByNumber(fromHex(blockNumber));\n      throwIfCancelled(isCancelled);\n      if (blockHash === hash) {\n        return fromHex(blockNumber);\n      }\n    }\n    return Number.NEGATIVE_INFINITY;\n  }\n\n  async function getLogsInRange(\n    filter: LogsSubscriptionFilter,\n    fromBlockInclusive: number,\n    toBlockExclusive: number,\n  ): Promise<LogsEvent[]> {\n    if (fromBlockInclusive >= toBlockExclusive) {\n      return [];\n    }\n    const rangeFilter: GetLogsOptions = {\n      ...filter,\n      fromBlock: toHex(fromBlockInclusive),\n      toBlock: toHex(toBlockExclusive - 1),\n    };\n    return jsonRpcSenders.send(\"eth_getLogs\", [rangeFilter]);\n  }\n\n  async function getBlockNumber(): Promise<number> {\n    const blockNumberHex: string = await jsonRpcSenders.send(\"eth_blockNumber\");\n    return fromHex(blockNumberHex);\n  }\n}\n\nfunction toNewHeadsEvent(head: BlockHead): NewHeadsEvent {\n  const result: NewHeadsEvent & Partial<BlockHead> = { ...head };\n  delete result.totalDifficulty;\n  delete result.transactions;\n  delete result.uncles;\n  return result;\n}\n\nexport function dedupeNewHeads(events: NewHeadsEvent[]): NewHeadsEvent[] {\n  return dedupe(events, (event) => event.hash);\n}\n\nexport function dedupeLogs(events: LogsEvent[]): LogsEvent[] {\n  return dedupe(events, (event) => `${event.blockHash}/${event.logIndex}`);\n}\n\nfunction dedupe<T>(items: T[], getKey: (item: T) => any): T[] {\n  const keysSeen: Set<any> = new Set();\n  const result: T[] = [];\n  items.forEach((item) => {\n    const key = getKey(item);\n    if (!keysSeen.has(key)) {\n      keysSeen.add(key);\n      result.push(item);\n    }\n  });\n  return result;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}